<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>MTG Deck Builder（タブ分割：検索 / デッキ）</title>

  <!-- PWA / Mobile -->
  <meta name="theme-color" content="#0b0c10">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <meta name="apple-mobile-web-app-title" content="MTG Deck">
  <link rel="manifest" href="manifest.webmanifest">

  <style>
    :root { --bg:#0b0c10; --panel:#13151b; --text:#e7e7e7; --muted:#a8a8a8; --line:#242836; }
    body { margin:0; font-family: system-ui, -apple-system, Segoe UI, Roboto, "Noto Sans JP", sans-serif; background:var(--bg); color:var(--text); }
    header { padding:14px 16px; border-bottom:1px solid var(--line); position:sticky; top:0; background:rgba(11,12,16,.92); backdrop-filter: blur(8px); z-index:10; }

    /* Tabs */
    .topbar { display:flex; align-items:center; justify-content:space-between; gap:10px; flex-wrap:wrap; }
    .tabs { display:flex; gap:8px; }
    .tabbtn {
      padding:10px 12px; border-radius:12px; border:1px solid var(--line);
      background:#121623; color:var(--text); cursor:pointer; font-weight:700;
    }
    .tabbtn[aria-selected="true"] { background:#1b2130; outline: 2px solid rgba(255,255,255,.10); }
    .tabhint { font-size:12px; color:var(--muted); line-height:1.4; }

    .toolbar { display:flex; gap:8px; align-items:center; flex-wrap:wrap; margin-top:10px; }
    input[type="text"], input[type="search"], input[type="text"].smallin {
      padding:10px 12px; border-radius:10px; border:1px solid var(--line); background:#0f1117; color:var(--text);
    }
    input[type="text"]#q { flex:1; min-width: 240px; }
    button, select {
      padding:10px 12px; border-radius:10px; border:1px solid var(--line); background:#171b25; color:var(--text); cursor:pointer;
    }
    button:hover { background:#1b2130; }
    label { display:flex; align-items:center; gap:8px; font-size:12px; color:var(--muted); user-select:none; }

    .content { padding:12px; }
    .panel { background:var(--panel); border:1px solid var(--line); border-radius:12px; overflow:hidden; }
    .status { padding:10px 12px; border-top:1px solid var(--line); color:var(--muted); font-size:12px; white-space:pre-wrap; }

    .grid { display:grid; grid-template-columns: repeat(auto-fill, minmax(160px, 1fr)); gap:10px; padding:12px; }
    .card { border:1px solid var(--line); border-radius:12px; overflow:hidden; background:#0f1117; display:flex; flex-direction:column; }
    .card img { width:100%; aspect-ratio: 0.714; object-fit: cover; background:#0b0c10; }
    .card .meta { padding:10px; display:flex; flex-direction:column; gap:6px; }
    .card .name { font-size:13px; line-height:1.25; }
    .card .sub { font-size:12px; color:var(--muted); }
    .card .actions { display:flex; gap:6px; flex-wrap:wrap; }

    /* Deck UI */
    .deck { padding:12px; display:flex; flex-direction:column; gap:12px; }
    .deckbar { display:flex; gap:8px; flex-wrap:wrap; align-items:center; }
    .deckbar .smallin { width: 180px; }
    .pill { font-size:11px; color:var(--muted); border:1px solid var(--line); padding:4px 8px; border-radius:999px; }

    .boards { display:flex; gap:10px; }
    .board { flex:1; border:1px solid var(--line); border-radius:12px; background:#0f1117; overflow:hidden; min-width: 0; }
    .boardhead { padding:10px 10px; border-bottom:1px solid var(--line); display:flex; align-items:center; justify-content:space-between; gap:8px; }
    .boardhead .title { font-size:13px; color:var(--text); font-weight:700; }
    .boardhead .count { font-size:12px; color:var(--muted); font-variant-numeric: tabular-nums; }

    .tileWrap { padding:10px; }
    .tileGrid {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(64px, 1fr));
      gap: 6px;
      max-height: 58vh;
      overflow: auto;
      padding-right: 4px;  
    }
    .tile {
      position:relative;
      border:1px solid var(--line);
      border-radius:12px;
      background:#0b0c10;
      overflow:hidden;
      cursor:pointer;
      user-select:none;
      -webkit-tap-highlight-color: transparent;
      touch-action: manipulation;
    }
    .tile img { width:100%; aspect-ratio: 0.714; object-fit: cover; display:block; background:#07080c; pointer-events:none; }
    .badge {
      position: absolute;
      top: 4px;
      right: 4px;
      min-width: 18px;
      padding: 2px 5px;
      border-radius: 999px;
      background: rgba(0,0,0,.75);
      border: 1px solid rgba(255,255,255,.25);
      color: #fff;
      font-size: 11px;
      font-weight: 700;
      text-align: center;
      font-variant-numeric: tabular-nums;
      pointer-events: none;
    }
    .tileFooter {
      display: none;
    }
    .tile:hover .tileFooter {
      display: block;
    }
    .tileHelp { font-size:11px; color:var(--muted); margin-top:8px; line-height:1.35; }

    textarea { width:100%; height:140px; border-radius:10px; border:1px solid var(--line); background:#0f1117; color:var(--text); padding:10px; resize:vertical; }

    /* Views */
    .view { display:none; }
    .view.active { display:block; }

    /* Mobile */
    @media (max-width: 980px) {
      .boards { flex-direction: column; }
      .tileGrid { max-height: 46vh; }
      input[type="text"]#q { min-width: 180px; }
      .topbar { gap:8px; }
    }
  </style>
</head>
<body>
<header>
  <div class="topbar">
    <div class="tabs" role="tablist" aria-label="画面切替">
      <button id="tabSearch" class="tabbtn" role="tab" aria-selected="true">検索</button>
      <button id="tabDeck" class="tabbtn" role="tab" aria-selected="false">デッキ</button>
    </div>
    <div class="tabhint" id="tabHint">
      検索でカードを見つけて追加 → デッキで枚数調整（タップ:+1 / 長押し:-1 / ダブルタップ:移動）
    </div>
  </div>

  <!-- 検索ビュー専用ツールバー -->
  <div id="searchToolbar" class="toolbar">
    <input id="q" type="text" placeholder='検索（例: tundra / bayou / 稲妻 / t:creature c:u ）' />
    <select id="order">
      <option value="name">並び: 名前</option>
      <option value="released">並び: 発売日</option>
      <option value="set">並び: セット</option>
    </select>

    <label><input id="preferJa" type="checkbox" checked> 日本語版を優先（あれば）</label>
    <label><input id="collapseSame" type="checkbox"> 同名カードは1種類だけ（代表=最新印刷）</label>

    <button id="btnSearch">検索</button>
    <button id="btnClear">クリア</button>
  </div>
</header>

<div class="content">
  <!-- ===== View: Search ===== -->
  <section id="viewSearch" class="view active">
    <div class="panel">
      <div id="results" class="grid"></div>
      <div id="status" class="status">待機中</div>
    </div>
  </section>

  <!-- ===== View: Deck ===== -->
  <section id="viewDeck" class="view">
    <div class="panel">
      <div class="deck">
        <div class="deckbar">
          <span class="pill">現在: <b id="currentDeckName">（未保存）</b></span>
          <input id="deckName" class="smallin" type="text" placeholder="デッキ名（保存用）" />
          <button id="btnSaveDeck">保存</button>
          <select id="deckSelect"></select>
          <button id="btnLoadDeck">読み込み</button>
          <button id="btnDeleteDeck">削除</button>
          <button id="btnNewDeck">新規</button>
        </div>

        <div class="boards">
          <div class="board">
            <div class="boardhead">
              <div class="title">Main</div>
              <div class="count"><span id="mainCount">0</span>枚</div>
            </div>
            <div class="tileWrap">
              <div id="mainTiles" class="tileGrid"></div>
              <div class="tileHelp">操作：タップ/クリック +1 ／ 長押し(0.5秒) or 右クリック -1 ／ ダブルタップで Sideへ移動</div>
            </div>
          </div>

          <div class="board">
            <div class="boardhead">
              <div class="title">Side</div>
              <div class="count"><span id="sideCount">0</span>枚</div>
            </div>
            <div class="tileWrap">
              <div id="sideTiles" class="tileGrid"></div>
              <div class="tileHelp">操作：タップ/クリック +1 ／ 長押し(0.5秒) or 右クリック -1 ／ ダブルタップで Mainへ移動</div>
            </div>
          </div>
        </div>

        <div style="display:flex; gap:8px; flex-wrap:wrap; align-items:center;">
          <button id="btnExport" style="flex:1;">エクスポート</button>
          <button id="btnClearBoards">Main/Side 全消し</button>
        </div>
        <textarea id="exportBox" placeholder="ここにデッキリストを出力（コピー用）"></textarea>
      </div>
    </div>
  </section>
</div>

<script>
(() => {
  const $ = (id) => document.getElementById(id);
  const STORE_KEY = "mtg_deck_store_tabs_v1";

  const state = {
    results: [],
    currentDeckName: "",
    deck: newEmptyDeck(""),
  };

  /* ===== View switching ===== */
  function setView(view) {
    const isSearch = view === "search";
    $("viewSearch").classList.toggle("active", isSearch);
    $("viewDeck").classList.toggle("active", !isSearch);

    $("tabSearch").setAttribute("aria-selected", String(isSearch));
    $("tabDeck").setAttribute("aria-selected", String(!isSearch));

    // 検索時だけ検索ツールバーを見せる（ヘッダがスッキリする）
    $("searchToolbar").style.display = isSearch ? "flex" : "none";

    // ハッシュ更新（戻る/進むで画面が戻る）
    const nextHash = isSearch ? "#search" : "#deck";
    if (location.hash !== nextHash) history.pushState(null, "", nextHash);
  }

  function syncViewFromHash() {
    const h = (location.hash || "").toLowerCase();
    if (h === "#deck") setView("deck");
    else setView("search");
  }

  $("tabSearch").onclick = () => setView("search");
  $("tabDeck").onclick = () => setView("deck");
  window.addEventListener("popstate", syncViewFromHash);
  window.addEventListener("hashchange", syncViewFromHash);

  /* ===== helpers ===== */
  function setStatus(msg) { $("status").textContent = msg; }

  function newEmptyDeck(name) {
    return { name, updatedAt: new Date().toISOString(), main: {}, side: {} };
  }

  function loadStore() {
    try {
      const raw = localStorage.getItem(STORE_KEY);
      if (!raw) return { version: 1, decks: {} };
      const s = JSON.parse(raw);
      if (!s || typeof s !== "object") return { version: 1, decks: {} };
      if (!s.decks) s.decks = {};
      return s;
    } catch {
      return { version: 1, decks: {} };
    }
  }

  function saveStore(store) { localStorage.setItem(STORE_KEY, JSON.stringify(store)); }

  function refreshDeckSelect() {
    const store = loadStore();
    const sel = $("deckSelect");
    sel.innerHTML = "";
    const names = Object.keys(store.decks).sort((a,b)=>a.localeCompare(b));
    const opt0 = document.createElement("option");
    opt0.value = "";
    opt0.textContent = "保存デッキを選択…";
    sel.appendChild(opt0);
    for (const n of names) {
      const opt = document.createElement("option");
      opt.value = n;
      opt.textContent = n;
      sel.appendChild(opt);
    }
  }

  function setCurrentDeckName(name) {
    state.currentDeckName = name;
    $("currentDeckName").textContent = name ? name : "（未保存）";
  }

  /* ===== Scryfall ===== */
  function looksJapanese(s) { return /[\u3040-\u30FF\u4E00-\u9FFF]/.test(s); }

  function isAdvancedQuery(s) {
    return /(^|\s)(t:|c:|o:|oracle:|f:|format:|lang:|is:|set:|cn:|rarity:|type:|pow|tou|cmc)\b/i.test(s) || /[:"]/g.test(s);
  }

  function getCardImage(card) {
    if (card.image_uris?.normal) return card.image_uris.normal;
    if (Array.isArray(card.card_faces)) {
      for (const f of card.card_faces) if (f.image_uris?.normal) return f.image_uris.normal;
    }
    return "";
  }

  function normalizeCard(card) {
    return {
      id: card.id,
      oracle_id: card.oracle_id,
      name: card.name,
      set: (card.set || "").toUpperCase(),
      collector: card.collector_number || "",
      lang: card.lang || "",
      released_at: card.released_at || "",
      scryfall_uri: card.scryfall_uri,
      image: getCardImage(card)
    };
  }

  async function fetchSearch(q) {
    const url = new URL("https://api.scryfall.com/cards/search");
    url.searchParams.set("q", q);
    url.searchParams.set("unique", "prints");
    url.searchParams.set("order", $("order").value);
    const res = await fetch(url.toString(), { headers: { "Accept": "application/json" } });
    const data = await res.json().catch(() => ({}));
    return { ok: res.ok, data, status: res.status };
  }

  function dateKey(released_at) { return (released_at && typeof released_at === "string") ? released_at : ""; }
  function exactRank(cardName, query) {
    const a = (cardName || "").trim().toLowerCase();
    const q = (query || "").trim().toLowerCase();
    return a === q ? 0 : 1;
  }

  function pickBestPrint(cards, query, preferJa) {
    let best = null;
    for (const c of cards) {
      if (!best) { best = c; continue; }
      if (preferJa) {
        const aj = (c.lang === "ja") ? 0 : 1;
        const bj = (best.lang === "ja") ? 0 : 1;
        if (aj !== bj) { if (aj < bj) best = c; continue; }
      }
      const ad = dateKey(c.released_at);
      const bd = dateKey(best.released_at);
      if (ad !== bd) { if (ad > bd) best = c; continue; }
      const ae = exactRank(c.name, query);
      const be = exactRank(best.name, query);
      if (ae !== be) { if (ae < be) best = c; continue; }
      const aKey = ((c.set||"") + "|" + (c.collector||"") + "|" + (c.id||"")).toLowerCase();
      const bKey = ((best.set||"") + "|" + (best.collector||"") + "|" + (best.id||"")).toLowerCase();
      if (aKey > bKey) best = c;
    }
    return best;
  }

  function applyCollapseSame(cards, query, preferJa, collapseSame) {
    if (!collapseSame) return cards;
    const groups = new Map();
    for (const c of cards) {
      const k = c.oracle_id || c.id;
      if (!groups.has(k)) groups.set(k, []);
      groups.get(k).push(c);
    }
    const picked = [];
    for (const arr of groups.values()) picked.push(pickBestPrint(arr, query, preferJa));
    return picked;
  }

  function sortResults(cards, query, preferJa) {
    const qLower = (query || "").trim().toLowerCase();
    cards.sort((a, b) => {
      const ae = (a.name || "").toLowerCase() === qLower ? 0 : 1;
      const be = (b.name || "").toLowerCase() === qLower ? 0 : 1;
      if (ae !== be) return ae - be;

      if (preferJa) {
        const aj = (a.lang === "ja") ? 0 : 1;
        const bj = (b.lang === "ja") ? 0 : 1;
        if (aj !== bj) return aj - bj;
      }

      const an = (a.name || "").toLowerCase();
      const bn = (b.name || "").toLowerCase();
      if (an !== bn) return an.localeCompare(bn);

      const ad = dateKey(a.released_at);
      const bd = dateKey(b.released_at);
      if (ad !== bd) return bd.localeCompare(ad);

      return (a.set || "").localeCompare(b.set || "");
    });
    return cards;
  }

  async function searchCards(rawInput) {
    const s = rawInput.trim();
    if (!s) {
      state.results = [];
      renderResults();
      setStatus("検索ワードを入力してください");
      return;
    }

    const preferJa = $("preferJa").checked;
    const collapseSame = $("collapseSame").checked;
    setStatus("検索中…");

    if (isAdvancedQuery(s)) {
      const queries = (preferJa && looksJapanese(s) && !/(^|\s)lang:/i.test(s))
        ? [`lang:ja ${s}`, s]
        : [s];

      for (const q of queries) {
        const r = await fetchSearch(q);
        const arr = Array.isArray(r.data?.data) ? r.data.data : [];
        if (arr.length > 0) {
          let cards = arr.map(normalizeCard);
          cards = applyCollapseSame(cards, s, preferJa, collapseSame);
          cards = sortResults(cards, s, preferJa);
          state.results = cards;
          renderResults();
          setStatus(`ヒット: ${cards.length}件\nq=${q}`);
          return;
        }
      }
      state.results = [];
      renderResults();
      setStatus("見つかりませんでした");
      return;
    }

    const mergedById = new Map();
    const pushAll = (arr) => { for (const c of arr) mergedById.set(c.id, c); };

    if (preferJa) {
      const rJa = await fetchSearch(`lang:ja ${s}`);
      pushAll(Array.isArray(rJa.data?.data) ? rJa.data.data : []);
    }
    const rAny = await fetchSearch(s);
    pushAll(Array.isArray(rAny.data?.data) ? rAny.data.data : []);

    if (mergedById.size > 0) {
      let cards = Array.from(mergedById.values()).map(normalizeCard);
      cards = applyCollapseSame(cards, s, preferJa, collapseSame);
      cards = sortResults(cards, s, preferJa);
      state.results = cards;
      renderResults();
      setStatus(`ヒット: ${cards.length}件\nq=${preferJa ? "lang:ja " + s + " + " + s : s}`);

      // 検索→追加が目的なら、必要ならここで自動的に検索画面に留める（何もしない）
      return;
    }

    state.results = [];
    renderResults();
    setStatus("見つかりませんでした");
  }

  /* ===== Deck (Main/Side) ===== */
  function boardObj(board) { return board === "side" ? state.deck.side : state.deck.main; }

  function addToBoard(board, card, delta = 1) {
    const obj = boardObj(board);
    const cur = obj[card.id];
    if (cur) cur.qty += delta;
    else obj[card.id] = { ...card, qty: delta };

    if (obj[card.id] && obj[card.id].qty <= 0) delete obj[card.id];
    state.deck.updatedAt = new Date().toISOString();
    renderDeck();
  }

  function changeQty(board, cardId, delta) {
    const obj = boardObj(board);
    const it = obj[cardId];
    if (!it) return;
    it.qty += delta;
    if (it.qty <= 0) delete obj[cardId];
    state.deck.updatedAt = new Date().toISOString();
    renderDeck();
  }

  function moveCard(from, to, cardId) {
    if (from === to) return;
    const a = boardObj(from);
    const b = boardObj(to);
    const it = a[cardId];
    if (!it) return;
    if (b[cardId]) b[cardId].qty += it.qty;
    else b[cardId] = it;
    delete a[cardId];
    state.deck.updatedAt = new Date().toISOString();
    renderDeck();
  }

  function countBoard(obj) { return Object.values(obj).reduce((sum, x) => sum + (x.qty || 0), 0); }
  function listEntries(obj) { return Object.values(obj).sort((a,b) => (a.name||"").localeCompare(b.name||"")); }

  function exportDeck() {
    const lines = [];
    lines.push("Main");
    for (const it of listEntries(state.deck.main)) lines.push(`${it.qty} ${it.name}`);
    lines.push("");
    lines.push("Side");
    for (const it of listEntries(state.deck.side)) lines.push(`${it.qty} ${it.name}`);
    $("exportBox").value = lines.join("\n");
  }

  function clearBoards() {
    state.deck.main = {};
    state.deck.side = {};
    state.deck.updatedAt = new Date().toISOString();
    setCurrentDeckName("");
    renderDeck();
    $("exportBox").value = "";
  }

  /* ===== Save/Load ===== */
  function saveCurrentDeck() {
    const name = $("deckName").value.trim();
    if (!name) { setStatus("デッキ名を入力してください（デッキ画面）"); return; }
    const store = loadStore();
    const toSave = structuredClone(state.deck);
    toSave.name = name;
    toSave.updatedAt = new Date().toISOString();
    store.decks[name] = toSave;
    saveStore(store);
    setCurrentDeckName(name);
    refreshDeckSelect();
    setStatus(`保存しました: ${name}`);
  }

  function loadDeckByName(name) {
    const store = loadStore();
    const d = store.decks[name];
    if (!d) { setStatus(`見つかりません: ${name}`); return; }
    state.deck = { name: d.name || name, updatedAt: d.updatedAt || new Date().toISOString(), main: d.main || {}, side: d.side || {} };
    setCurrentDeckName(name);
    $("deckName").value = name;
    renderDeck();
    setStatus(`読み込みました: ${name}`);
  }

  function deleteDeckByName(name) {
    const store = loadStore();
    if (!store.decks[name]) { setStatus(`見つかりません: ${name}`); return; }
    delete store.decks[name];
    saveStore(store);
    refreshDeckSelect();
    setStatus(`削除しました: ${name}`);
    if (state.currentDeckName === name) { setCurrentDeckName(""); $("deckName").value = ""; }
  }

  function newDeck() {
    state.deck = newEmptyDeck("");
    setCurrentDeckName("");
    $("deckName").value = "";
    renderDeck();
    $("exportBox").value = "";
    setStatus("新規デッキを作成しました");
  }

  /* ===== Render results ===== */
  function renderResults() {
    const el = $("results");
    el.innerHTML = "";

    for (const c of state.results) {
      const wrap = document.createElement("div");
      wrap.className = "card";

      const img = document.createElement("img");
      img.loading = "lazy";
      img.alt = c.name;
      img.src = c.image || "";
      img.onerror = () => { img.style.display = "none"; };

      const meta = document.createElement("div");
      meta.className = "meta";

      const name = document.createElement("div");
      name.className = "name";
      name.textContent = c.name;

      const sub = document.createElement("div");
      sub.className = "sub";
      sub.textContent = `${c.set}${c.collector ? " #" + c.collector : ""}${c.lang ? " / " + c.lang : ""}${c.released_at ? " / " + c.released_at : ""}`;

      const actions = document.createElement("div");
      actions.className = "actions";

      const btnMain = document.createElement("button");
      btnMain.textContent = "Mainに追加";
      btnMain.onclick = () => addToBoard("main", c, 1);

      const btnSide = document.createElement("button");
      btnSide.textContent = "Sideに追加";
      btnSide.onclick = () => addToBoard("side", c, 1);

      const btnOpen = document.createElement("button");
      btnOpen.textContent = "Scryfall";
      btnOpen.onclick = () => window.open(c.scryfall_uri, "_blank", "noopener,noreferrer");

      actions.append(btnMain, btnSide, btnOpen);
      meta.append(name, sub, actions);

      wrap.append(img, meta);
      el.appendChild(wrap);
    }
  }

  /* ===== Tiles (tap + long press) ===== */
  function attachTileInteractions(tile, boardName, cardId) {
    const LONG_PRESS_MS = 500;
    let pressTimer = null;
    let longPressed = false;

    const clearPress = () => {
      if (pressTimer) { clearTimeout(pressTimer); pressTimer = null; }
    };

    tile.addEventListener("pointerdown", () => {
      longPressed = false;
      clearPress();
      pressTimer = setTimeout(() => {
        longPressed = true;
        changeQty(boardName, cardId, -1);
      }, LONG_PRESS_MS);
    });

    tile.addEventListener("pointerup", () => clearPress());
    tile.addEventListener("pointercancel", () => clearPress());
    tile.addEventListener("pointerleave", () => clearPress());

    tile.addEventListener("click", (e) => {
      e.preventDefault();
      if (longPressed) { longPressed = false; return; }
      changeQty(boardName, cardId, +1);
    });

    tile.addEventListener("contextmenu", (e) => {
      e.preventDefault();
      clearPress();
      changeQty(boardName, cardId, -1);
    });

    tile.addEventListener("dblclick", (e) => {
      e.preventDefault();
      clearPress();
      const to = boardName === "main" ? "side" : "main";
      moveCard(boardName, to, cardId);
    });
  }

  function makeTile(boardName, it) {
    const tile = document.createElement("div");
    tile.className = "tile";
    tile.title = `${it.qty}x ${it.name}\nタップ/クリック:+1 / 長押し or 右クリック:-1 / ダブルタップ:移動`;

    const img = document.createElement("img");
    img.alt = it.name;
    img.src = it.image || "";
    img.loading = "lazy";
    img.onerror = () => { img.style.display = "none"; };

    const badge = document.createElement("div");
    badge.className = "badge";
    badge.textContent = it.qty;

    const footer = document.createElement("div");
    footer.className = "tileFooter";
    footer.textContent = it.name;

    attachTileInteractions(tile, boardName, it.id);
    tile.append(img, badge, footer);
    return tile;
  }

  function renderTiles(container, obj, boardName) {
    container.innerHTML = "";
    for (const it of listEntries(obj)) container.appendChild(makeTile(boardName, it));
  }

  function renderDeck() {
    $("mainCount").textContent = countBoard(state.deck.main);
    $("sideCount").textContent = countBoard(state.deck.side);
    renderTiles($("mainTiles"), state.deck.main, "main");
    renderTiles($("sideTiles"), state.deck.side, "side");
  }

  /* ===== events ===== */
  $("btnSearch").onclick = () => searchCards($("q").value);
  $("btnClear").onclick = () => { $("q").value = ""; state.results = []; renderResults(); setStatus("クリアしました"); };
  $("q").addEventListener("keydown", (e) => { if (e.key === "Enter") searchCards($("q").value); });
  $("order").addEventListener("change", () => { if ($("q").value.trim()) searchCards($("q").value); });
  $("preferJa").addEventListener("change", () => { if ($("q").value.trim()) searchCards($("q").value); });
  $("collapseSame").addEventListener("change", () => { if ($("q").value.trim()) searchCards($("q").value); });

  $("btnExport").onclick = exportDeck;
  $("btnClearBoards").onclick = clearBoards;

  $("btnSaveDeck").onclick = saveCurrentDeck;
  $("btnLoadDeck").onclick = () => {
    const name = $("deckSelect").value;
    if (!name) { setStatus("読み込むデッキを選択してください"); return; }
    loadDeckByName(name);
  };
  $("btnDeleteDeck").onclick = () => {
    const name = $("deckSelect").value || state.currentDeckName;
    if (!name) { setStatus("削除するデッキを選択してください"); return; }
    if (!confirm(`デッキ「${name}」を削除します。よろしいですか？`)) return;
    deleteDeckByName(name);
  };
  $("btnNewDeck").onclick = () => {
    if (!confirm("新規デッキを作成します（現在の未保存の変更は失われます）。よろしいですか？")) return;
    newDeck();
  };

  /* ===== init ===== */
  refreshDeckSelect();
  setCurrentDeckName("");
  renderResults();
  renderDeck();
  setStatus("待機中");

  // 初期ビュー（ハッシュに従う）
  syncViewFromHash();
})();
</script>

<!-- Service Worker -->
<script>
if ("serviceWorker" in navigator) {
  navigator.serviceWorker.register("./sw.js").catch(() => {});
}
</script>
</body>
</html>

