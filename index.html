<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>MTG Deck Builder</title>

  <!-- PWA / Mobile -->
  <meta name="theme-color" content="#0b0c10">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <meta name="apple-mobile-web-app-title" content="MTG Deck">
  <link rel="manifest" href="manifest.webmanifest">

  <style>
    :root { --bg:#0b0c10; --panel:#13151b; --text:#e7e7e7; --muted:#a8a8a8; --line:#242836; }
    body { margin:0; font-family: system-ui, -apple-system, Segoe UI, Roboto, "Noto Sans JP", sans-serif; background:var(--bg); color:var(--text); }
    header { padding:14px 16px; border-bottom:1px solid var(--line); position:sticky; top:0; background:rgba(11,12,16,.92); backdrop-filter: blur(8px); z-index:10; }

    /* Tabs */
    .topbar { display:flex; align-items:center; justify-content:space-between; gap:10px; flex-wrap:wrap; }
    .tabs { display:flex; gap:8px; }
    .tabbtn {
      padding:10px 12px; border-radius:12px; border:1px solid var(--line);
      background:#121623; color:var(--text); cursor:pointer; font-weight:700;
    }
    .tabbtn[aria-selected="true"] { background:#1b2130; outline: 2px solid rgba(255,255,255,.10); }
    .tabhint { font-size:12px; color:var(--muted); line-height:1.4; }

    .content { padding:12px; }
    .panel { background:var(--panel); border:1px solid var(--line); border-radius:12px; overflow:hidden; }
    .status { padding:10px 12px; border-top:1px solid var(--line); color:var(--muted); font-size:12px; white-space:pre-wrap; }

    input[type="text"], input[type="search"], input[type="text"].smallin {
      padding:10px 12px; border-radius:10px; border:1px solid var(--line); background:#0f1117; color:var(--text);
    }
    button, select {
      padding:10px 12px; border-radius:10px; border:1px solid var(--line); background:#171b25; color:var(--text); cursor:pointer;
    }
    button:hover { background:#1b2130; }
    label { display:flex; align-items:center; gap:8px; font-size:12px; color:var(--muted); user-select:none; }

    .pill { font-size:11px; color:var(--muted); border:1px solid var(--line); padding:4px 8px; border-radius:999px; }

    /* Search - grid cards (big) */
    .grid { display:grid; grid-template-columns: repeat(auto-fill, minmax(140px, 1fr)); gap:10px; padding:12px; }
    .card { border:1px solid var(--line); border-radius:12px; overflow:hidden; background:#0f1117; display:flex; flex-direction:column; }
    .card img { width:100%; aspect-ratio: 0.714; object-fit: cover; background:#0b0c10; }
    .card .meta { padding:10px; display:flex; flex-direction:column; gap:6px; }
    .card .name { font-size:13px; line-height:1.25; }
    .card .sub { font-size:12px; color:var(--muted); }
    .card .actions { display:flex; gap:6px; flex-wrap:wrap; }

    /* Search - list rows (small image + name) */
    .list { display:flex; flex-direction:column; gap:8px; padding:12px; }
    .row {
      display:grid;
      grid-template-columns: 56px 1fr auto;
      gap:10px;
      align-items:center;
      border:1px solid var(--line);
      border-radius:12px;
      background:#0f1117;
      padding:8px;
    }
    .row img {
      width:56px; height:78px;
      object-fit:cover;
      border-radius:8px;
      background:#0b0c10;
    }
    .row .rmeta { min-width:0; }
    .row .rname {
      font-size:14px; font-weight:700; line-height:1.2; margin-bottom:4px;
      overflow:hidden; text-overflow:ellipsis; white-space:nowrap;
    }
    .row .rsub {
      font-size:12px; color:var(--muted);
      overflow:hidden; text-overflow:ellipsis; white-space:nowrap;
    }
    .row .ractions { display:flex; gap:6px; flex-wrap:wrap; justify-content:flex-end; }
    .row .ractions button { padding:8px 10px; }

    /* Deck UI */
    .deck { padding:12px; display:flex; flex-direction:column; gap:12px; }
    .deckbar { display:flex; gap:8px; flex-wrap:wrap; align-items:center; }
    .deckbar .smallin { width: 180px; }

    .boards { display:flex; gap:10px; }
    .board { flex:1; border:1px solid var(--line); border-radius:12px; background:#0f1117; overflow:hidden; min-width:0; }
    .boardhead { padding:10px 10px; border-bottom:1px solid var(--line); display:flex; align-items:center; justify-content:space-between; gap:8px; }
    .boardhead .title { font-size:13px; color:var(--text); font-weight:700; }
    .boardhead .count { font-size:12px; color:var(--muted); font-variant-numeric: tabular-nums; }

    .tileWrap { padding:10px; }
    .tileGrid {
      display:grid;
      grid-template-columns: repeat(auto-fill, minmax(64px, 1fr));
      gap:6px;
      max-height: 58vh;
      overflow:auto;
      padding-right:4px;
    }
    .tile {
      position:relative;
      border:1px solid var(--line);
      border-radius:12px;
      background:#0b0c10;
      overflow:hidden;
      cursor:pointer;
      user-select:none;
      -webkit-tap-highlight-color: transparent;
      touch-action: manipulation;
    }
    .tile img { width:100%; aspect-ratio:0.714; object-fit:cover; display:block; background:#07080c; pointer-events:none; }
    .badge {
      position:absolute;
      top:4px; right:4px;
      min-width:18px;
      padding:2px 5px;
      border-radius:999px;
      background:rgba(0,0,0,.75);
      border:1px solid rgba(255,255,255,.25);
      color:#fff;
      font-size:11px;
      font-weight:700;
      text-align:center;
      font-variant-numeric: tabular-nums;
      pointer-events:none;
    }
    .tileFooter { display:none; } /* アプリっぽく、タイル下の名前は非表示 */

    .tileHelp { font-size:11px; color:var(--muted); margin-top:8px; line-height:1.35; }
    textarea { width:100%; height:140px; border-radius:10px; border:1px solid var(--line); background:#0f1117; color:var(--text); padding:10px; resize:vertical; }

    /* Views */
    .view { display:none; }
    .view.active { display:block; }

    @media (max-width: 980px) {
      .boards { flex-direction: column; }
      .tileGrid { max-height: 46vh; grid-template-columns: repeat(auto-fill, minmax(60px, 1fr)); }
      .row { grid-template-columns: 52px 1fr; }
      .row .ractions { grid-column: 1 / -1; justify-content:flex-start; }
      .row img { width:52px; height:72px; }
    }
  </style>
</head>

<body>
<header>
  <div class="topbar">
    <div class="tabs" role="tablist" aria-label="画面切替">
      <button id="tabSearch" class="tabbtn" role="tab" aria-selected="true">検索</button>
      <button id="tabDeck" class="tabbtn" role="tab" aria-selected="false">デッキ</button>
    </div>
    <div class="tabhint">
      検索→追加→デッキで枚数調整（タップ:+1 / 長押し:-1 / ダブルタップ:Main⇔Side移動）
    </div>
  </div>
</header>

<div class="content">

  <!-- ===== View: Search ===== -->
  <section id="viewSearch" class="view active">

    <!-- Search: Form page -->
    <div id="searchPageForm" class="panel">
      <div class="status" style="border-top:none;">検索条件を入力して「検索」を押してください</div>

      <div style="padding:12px; display:flex; flex-direction:column; gap:10px;">
        <div style="display:flex; gap:8px; flex-wrap:wrap;">
          <input id="q" type="text" placeholder='検索（例: tundra / bayou / 稲妻 / t:creature c:u ）' style="flex:1; min-width:220px;" />
          <button id="btnSearch">検索</button>
          <button id="btnClear">クリア</button>
        </div>

        <div style="display:flex; gap:12px; flex-wrap:wrap; align-items:center;">
          <label><input id="preferJa" type="checkbox" checked> 日本語版を優先（あれば）</label>
          <label><input id="collapseSame" type="checkbox"> 同名カードは1種類だけ（代表=最新印刷）</label>

          <label style="display:flex; gap:8px; align-items:center;">
            並び:
            <select id="order">
              <option value="name">名前</option>
              <option value="released">発売日</option>
              <option value="set">セット</option>
            </select>
          </label>
        </div>

        <div class="status" id="statusForm" style="border-top:1px solid var(--line);">待機中</div>
      </div>
    </div>

    <!-- Search: Results page -->
    <div id="searchPageResults" class="panel" style="display:none;">
      <div style="padding:10px 12px; border-bottom:1px solid var(--line); display:flex; align-items:center; justify-content:space-between; gap:10px; flex-wrap:wrap;">
        <div style="display:flex; gap:8px; align-items:center;">
          <button id="btnBackToForm">← 条件へ戻る</button>
          <span class="pill">ヒット: <b id="hitCount">0</b></span>
        </div>

        <div style="display:flex; gap:8px; align-items:center; flex-wrap:wrap;">
          <span class="pill">表示</span>
          <button id="viewModeGrid" class="tabbtn" style="padding:8px 10px;">グリッド</button>
          <button id="viewModeList" class="tabbtn" style="padding:8px 10px;">リスト</button>
        </div>
      </div>

      <div id="resultsGrid" class="grid"></div>
      <div id="resultsList" class="list" style="display:none;"></div>

      <div id="status" class="status">待機中</div>
    </div>

  </section>

  <!-- ===== View: Deck ===== -->
  <section id="viewDeck" class="view">
    <div class="panel">
      <div class="deck">
        <div class="deckbar">
          <span class="pill">現在: <b id="currentDeckName">（未保存）</b></span>
          <input id="deckName" class="smallin" type="text" placeholder="デッキ名（保存用）" />
          <button id="btnSaveDeck">保存</button>
          <select id="deckSelect"></select>
          <button id="btnLoadDeck">読み込み</button>
          <button id="btnDeleteDeck">削除</button>
          <button id="btnNewDeck">新規</button>
        </div>

        <div class="boards">
          <div class="board">
            <div class="boardhead">
              <div class="title">Main</div>
              <div class="count"><span id="mainCount">0</span>枚</div>
            </div>
            <div class="tileWrap">
              <div id="mainTiles" class="tileGrid"></div>
              <div class="tileHelp">操作：タップ/クリック +1 ／ 長押し(0.5秒) or 右クリック -1 ／ ダブルタップで Sideへ移動</div>
            </div>
          </div>

          <div class="board">
            <div class="boardhead">
              <div class="title">Side</div>
              <div class="count"><span id="sideCount">0</span>枚</div>
            </div>
            <div class="tileWrap">
              <div id="sideTiles" class="tileGrid"></div>
              <div class="tileHelp">操作：タップ/クリック +1 ／ 長押し(0.5秒) or 右クリック -1 ／ ダブルタップで Mainへ移動</div>
            </div>
          </div>
        </div>

        <div style="display:flex; gap:8px; flex-wrap:wrap; align-items:center;">
          <button id="btnExport" style="flex:1;">エクスポート</button>
          <button id="btnClearBoards">Main/Side 全消し</button>
        </div>
        <textarea id="exportBox" placeholder="ここにデッキリストを出力（コピー用）"></textarea>
      </div>
    </div>
  </section>

</div>

<script>
(() => {
  const $ = (id) => document.getElementById(id);

  const STORE_KEY = "mtg_deck_store_tabs_v2";
  const SEARCH_UI_KEY = "mtg_search_ui_v1";

  const state = {
    results: [],
    currentDeckName: "",
    deck: newEmptyDeck(""),
  };

  /* ===== View switching (Search / Deck) ===== */
  function setView(view) {
    const isSearch = view === "search";
    $("viewSearch").classList.toggle("active", isSearch);
    $("viewDeck").classList.toggle("active", !isSearch);
    $("tabSearch").setAttribute("aria-selected", String(isSearch));
    $("tabDeck").setAttribute("aria-selected", String(!isSearch));

    const nextHash = isSearch ? "#search" : "#deck";
    if (location.hash !== nextHash) history.pushState(null, "", nextHash);
  }
  function syncViewFromHash() {
    const h = (location.hash || "").toLowerCase();
    if (h === "#deck") setView("deck");
    else setView("search");
  }
  $("tabSearch").onclick = () => setView("search");
  $("tabDeck").onclick = () => setView("deck");
  window.addEventListener("popstate", syncViewFromHash);
  window.addEventListener("hashchange", syncViewFromHash);

  /* ===== Search sub-pages + mode ===== */
  const searchUI = loadSearchUI();

  function loadSearchUI() {
    try {
      const raw = localStorage.getItem(SEARCH_UI_KEY);
      const v = raw ? JSON.parse(raw) : {};
      return { page: v.page || "form", mode: v.mode || "grid" };
    } catch {
      return { page:"form", mode:"grid" };
    }
  }
  function saveSearchUI() { localStorage.setItem(SEARCH_UI_KEY, JSON.stringify(searchUI)); }

  function setSearchPage(page) {
    searchUI.page = page; saveSearchUI();
    $("searchPageForm").style.display = (page === "form") ? "block" : "none";
    $("searchPageResults").style.display = (page === "results") ? "block" : "none";
  }

  function setResultsMode(mode) {
    searchUI.mode = mode; saveSearchUI();
    const isGrid = mode === "grid";
    $("resultsGrid").style.display = isGrid ? "grid" : "none";
    $("resultsList").style.display = isGrid ? "none" : "flex";
    $("viewModeGrid").setAttribute("aria-selected", String(isGrid));
    $("viewModeList").setAttribute("aria-selected", String(!isGrid));
  }

  /* ===== helpers ===== */
  function setStatus(msg) {
    $("status").textContent = msg;
    const sf = $("statusForm");
    if (sf) sf.textContent = msg;
  }

  function newEmptyDeck(name) {
    return { name, updatedAt: new Date().toISOString(), main: {}, side: {} };
  }

  function loadStore() {
    try {
      const raw = localStorage.getItem(STORE_KEY);
      if (!raw) return { version: 1, decks: {} };
      const s = JSON.parse(raw);
      if (!s || typeof s !== "object") return { version: 1, decks: {} };
      if (!s.decks) s.decks = {};
      return s;
    } catch {
      return { version: 1, decks: {} };
    }
  }
  function saveStore(store) { localStorage.setItem(STORE_KEY, JSON.stringify(store)); }

  function refreshDeckSelect() {
    const store = loadStore();
    const sel = $("deckSelect");
    sel.innerHTML = "";
    const names = Object.keys(store.decks).sort((a,b)=>a.localeCompare(b));
    const opt0 = document.createElement("option");
    opt0.value = "";
    opt0.textContent = "保存デッキを選択…";
    sel.appendChild(opt0);
    for (const n of names) {
      const opt = document.createElement("option");
      opt.value = n;
      opt.textContent = n;
      sel.appendChild(opt);
    }
  }
  function setCurrentDeckName(name) {
    state.currentDeckName = name;
    $("currentDeckName").textContent = name ? name : "（未保存）";
  }

  /* ===== Scryfall ===== */
  function looksJapanese(s) { return /[\u3040-\u30FF\u4E00-\u9FFF]/.test(s); }
  function isAdvancedQuery(s) {
    return /(^|\s)(t:|c:|o:|oracle:|f:|format:|lang:|is:|set:|cn:|rarity:|type:|pow|tou|cmc)\b/i.test(s) || /[:"]/g.test(s);
  }
  function getCardImage(card) {
    if (card.image_uris?.normal) return card.image_uris.normal;
    if (Array.isArray(card.card_faces)) {
      for (const f of card.card_faces) if (f.image_uris?.normal) return f.image_uris.normal;
    }
    return "";
  }
  function normalizeCard(card) {
    return {
      id: card.id,
      oracle_id: card.oracle_id,
      name: card.name,
      set: (card.set || "").toUpperCase(),
      collector: card.collector_number || "",
      lang: card.lang || "",
      released_at: card.released_at || "",
      scryfall_uri: card.scryfall_uri,
      image: getCardImage(card)
    };
  }

  async function fetchSearch(q) {
    const url = new URL("https://api.scryfall.com/cards/search");
    url.searchParams.set("q", q);
    url.searchParams.set("unique", "prints");
    url.searchParams.set("order", $("order").value);
    const res = await fetch(url.toString(), { headers: { "Accept": "application/json" } });
    const data = await res.json().catch(() => ({}));
    return { ok: res.ok, data, status: res.status };
  }

  function dateKey(released_at) { return (released_at && typeof released_at === "string") ? released_at : ""; }

  // exact match rank: 0 (exact) first
  function exactRank(cardName, query) {
    const a = (cardName || "").trim().toLowerCase();
    const q = (query || "").trim().toLowerCase();
    return a === q ? 0 : 1;
  }

  // pick representative print: (preferJa -> latest release -> exact match -> tie)
  function pickBestPrint(cards, query, preferJa) {
    let best = null;
    for (const c of cards) {
      if (!best) { best = c; continue; }

      if (preferJa) {
        const aj = (c.lang === "ja") ? 0 : 1;
        const bj = (best.lang === "ja") ? 0 : 1;
        if (aj !== bj) { if (aj < bj) best = c; continue; }
      }

      const ad = dateKey(c.released_at);
      const bd = dateKey(best.released_at);
      if (ad !== bd) { if (ad > bd) best = c; continue; } // latest

      const ae = exactRank(c.name, query);
      const be = exactRank(best.name, query);
      if (ae !== be) { if (ae < be) best = c; continue; }

      const aKey = ((c.set||"") + "|" + (c.collector||"") + "|" + (c.id||"")).toLowerCase();
      const bKey = ((best.set||"") + "|" + (best.collector||"") + "|" + (best.id||"")).toLowerCase();
      if (aKey > bKey) best = c;
    }
    return best;
  }

  function applyCollapseSame(cards, query, preferJa, collapseSame) {
    if (!collapseSame) return cards;
    const groups = new Map();
    for (const c of cards) {
      const k = c.oracle_id || c.id;
      if (!groups.has(k)) groups.set(k, []);
      groups.get(k).push(c);
    }
    const picked = [];
    for (const arr of groups.values()) picked.push(pickBestPrint(arr, query, preferJa));
    return picked;
  }

  // sort: exact match -> preferJa -> name -> release desc -> set
  function sortResults(cards, query, preferJa) {
    const qLower = (query || "").trim().toLowerCase();
    cards.sort((a, b) => {
      const ae = (a.name || "").toLowerCase() === qLower ? 0 : 1;
      const be = (b.name || "").toLowerCase() === qLower ? 0 : 1;
      if (ae !== be) return ae - be;

      if (preferJa) {
        const aj = (a.lang === "ja") ? 0 : 1;
        const bj = (b.lang === "ja") ? 0 : 1;
        if (aj !== bj) return aj - bj;
      }

      const an = (a.name || "").toLowerCase();
      const bn = (b.name || "").toLowerCase();
      if (an !== bn) return an.localeCompare(bn);

      const ad = dateKey(a.released_at);
      const bd = dateKey(b.released_at);
      if (ad !== bd) return bd.localeCompare(ad);

      return (a.set || "").localeCompare(b.set || "");
    });
    return cards;
  }

  async function searchCards(rawInput) {
    const s = rawInput.trim();
    if (!s) {
      state.results = [];
      renderResults();
      setStatus("検索ワードを入力してください");
      setSearchPage("form");
      return;
    }

    const preferJa = $("preferJa").checked;
    const collapseSame = $("collapseSame").checked;

    setStatus("検索中…");

    // Advanced query
    if (isAdvancedQuery(s)) {
      const queries = (preferJa && looksJapanese(s) && !/(^|\s)lang:/i.test(s))
        ? [`lang:ja ${s}`, s]
        : [s];

      for (const q of queries) {
        const r = await fetchSearch(q);
        const arr = Array.isArray(r.data?.data) ? r.data.data : [];
        if (arr.length > 0) {
          let cards = arr.map(normalizeCard);
          cards = applyCollapseSame(cards, s, preferJa, collapseSame);
          cards = sortResults(cards, s, preferJa);
          state.results = cards;
          renderResults();
          setStatus(`ヒット: ${cards.length}件\nq=${q}`);
          setSearchPage("results");
          return;
        }
      }
      state.results = [];
      renderResults();
      setStatus("見つかりませんでした");
      setSearchPage("results");
      return;
    }

    // Normal keyword: prefer ja + any language merge
    const mergedById = new Map();
    const pushAll = (arr) => { for (const c of arr) mergedById.set(c.id, c); };

    if (preferJa) {
      const rJa = await fetchSearch(`lang:ja ${s}`);
      pushAll(Array.isArray(rJa.data?.data) ? rJa.data.data : []);
    }
    const rAny = await fetchSearch(s);
    pushAll(Array.isArray(rAny.data?.data) ? rAny.data.data : []);

    if (mergedById.size > 0) {
      let cards = Array.from(mergedById.values()).map(normalizeCard);
      cards = applyCollapseSame(cards, s, preferJa, collapseSame);
      cards = sortResults(cards, s, preferJa);
      state.results = cards;
      renderResults();
      setStatus(`ヒット: ${cards.length}件\nq=${preferJa ? "lang:ja " + s + " + " + s : s}`);
      setSearchPage("results");
      return;
    }

    state.results = [];
    renderResults();
    setStatus("見つかりませんでした");
    setSearchPage("results");
  }

  /* ===== Deck (Main/Side) ===== */
  function boardObj(board) { return board === "side" ? state.deck.side : state.deck.main; }

  function addToBoard(board, card, delta = 1) {
    const obj = boardObj(board);
    const cur = obj[card.id];
    if (cur) cur.qty += delta;
    else obj[card.id] = { ...card, qty: delta };

    if (obj[card.id] && obj[card.id].qty <= 0) delete obj[card.id];
    state.deck.updatedAt = new Date().toISOString();
    renderDeck();
  }

  function changeQty(board, cardId, delta) {
    const obj = boardObj(board);
    const it = obj[cardId];
    if (!it) return;
    it.qty += delta;
    if (it.qty <= 0) delete obj[cardId];
    state.deck.updatedAt = new Date().toISOString();
    renderDeck();
  }

  function moveCard(from, to, cardId) {
    if (from === to) return;
    const a = boardObj(from);
    const b = boardObj(to);
    const it = a[cardId];
    if (!it) return;
    if (b[cardId]) b[cardId].qty += it.qty;
    else b[cardId] = it;
    delete a[cardId];
    state.deck.updatedAt = new Date().toISOString();
    renderDeck();
  }

  function countBoard(obj) { return Object.values(obj).reduce((sum, x) => sum + (x.qty || 0), 0); }
  function listEntries(obj) { return Object.values(obj).sort((a,b) => (a.name||"").localeCompare(b.name||"")); }

  function exportDeck() {
    const lines = [];
    lines.push("Main");
    for (const it of listEntries(state.deck.main)) lines.push(`${it.qty} ${it.name}`);
    lines.push("");
    lines.push("Side");
    for (const it of listEntries(state.deck.side)) lines.push(`${it.qty} ${it.name}`);
    $("exportBox").value = lines.join("\n");
  }

  function clearBoards() {
    state.deck.main = {};
    state.deck.side = {};
    state.deck.updatedAt = new Date().toISOString();
    setCurrentDeckName("");
    renderDeck();
    $("exportBox").value = "";
  }

  /* ===== Save/Load ===== */
  function saveCurrentDeck() {
    const name = $("deckName").value.trim();
    if (!name) { setStatus("デッキ名を入力してください（デッキ画面）"); return; }
    const store = loadStore();
    const toSave = structuredClone(state.deck);
    toSave.name = name;
    toSave.updatedAt = new Date().toISOString();
    store.decks[name] = toSave;
    saveStore(store);
    setCurrentDeckName(name);
    refreshDeckSelect();
    setStatus(`保存しました: ${name}`);
  }

  function loadDeckByName(name) {
    const store = loadStore();
    const d = store.decks[name];
    if (!d) { setStatus(`見つかりません: ${name}`); return; }
    state.deck = { name: d.name || name, updatedAt: d.updatedAt || new Date().toISOString(), main: d.main || {}, side: d.side || {} };
    setCurrentDeckName(name);
    $("deckName").value = name;
    renderDeck();
    setStatus(`読み込みました: ${name}`);
  }

  function deleteDeckByName(name) {
    const store = loadStore();
    if (!store.decks[name]) { setStatus(`見つかりません: ${name}`); return; }
    delete store.decks[name];
    saveStore(store);
    refreshDeckSelect();
    setStatus(`削除しました: ${name}`);
    if (state.currentDeckName === name) { setCurrentDeckName(""); $("deckName").value = ""; }
  }

  function newDeck() {
    state.deck = newEmptyDeck("");
    setCurrentDeckName("");
    $("deckName").value = "";
    renderDeck();
    $("exportBox").value = "";
    setStatus("新規デッキを作成しました");
  }

  /* ===== Render results (Grid + List) ===== */
  function renderResults() {
    const grid = $("resultsGrid");
    const list = $("resultsList");
    grid.innerHTML = "";
    list.innerHTML = "";

    $("hitCount").textContent = String(state.results.length);

    for (const c of state.results) {
      // grid card
      const wrap = document.createElement("div");
      wrap.className = "card";

      const img = document.createElement("img");
      img.loading = "lazy";
      img.alt = c.name;
      img.src = c.image || "";
      img.onerror = () => { img.style.display = "none"; };

      const meta = document.createElement("div");
      meta.className = "meta";

      const name = document.createElement("div");
      name.className = "name";
      name.textContent = c.name;

      const sub = document.createElement("div");
      sub.className = "sub";
      sub.textContent = `${c.set}${c.collector ? " #" + c.collector : ""}${c.lang ? " / " + c.lang : ""}${c.released_at ? " / " + c.released_at : ""}`;

      const actions = document.createElement("div");
      actions.className = "actions";

      const btnMain = document.createElement("button");
      btnMain.textContent = "Mainに追加";
      btnMain.onclick = () => addToBoard("main", c, 1);

      const btnSide = document.createElement("button");
      btnSide.textContent = "Sideに追加";
      btnSide.onclick = () => addToBoard("side", c, 1);

      const btnOpen = document.createElement("button");
      btnOpen.textContent = "Scryfall";
      btnOpen.onclick = () => window.open(c.scryfall_uri, "_blank", "noopener,noreferrer");

      actions.append(btnMain, btnSide, btnOpen);
      meta.append(name, sub, actions);
      wrap.append(img, meta);
      grid.appendChild(wrap);

      // list row
      const row = document.createElement("div");
      row.className = "row";

      const limg = document.createElement("img");
      limg.loading = "lazy";
      limg.alt = c.name;
      limg.src = c.image || "";
      limg.onerror = () => { limg.style.display = "none"; };

      const rmeta = document.createElement("div");
      rmeta.className = "rmeta";

      const rname = document.createElement("div");
      rname.className = "rname";
      rname.textContent = c.name;

      const rsub = document.createElement("div");
      rsub.className = "rsub";
      rsub.textContent = `${c.set}${c.collector ? " #" + c.collector : ""}${c.lang ? " / " + c.lang : ""}${c.released_at ? " / " + c.released_at : ""}`;

      rmeta.append(rname, rsub);

      const ractions = document.createElement("div");
      ractions.className = "ractions";

      const lMain = document.createElement("button");
      lMain.textContent = "Main";
      lMain.onclick = () => addToBoard("main", c, 1);

      const lSide = document.createElement("button");
      lSide.textContent = "Side";
      lSide.onclick = () => addToBoard("side", c, 1);

      const lOpen = document.createElement("button");
      lOpen.textContent = "詳細";
      lOpen.onclick = () => window.open(c.scryfall_uri, "_blank", "noopener,noreferrer");

      ractions.append(lMain, lSide, lOpen);

      row.append(limg, rmeta, ractions);
      list.appendChild(row);
    }
  }

  /* ===== Tiles (tap + long press + dblclick) ===== */
  function attachTileInteractions(tile, boardName, cardId) {
    const LONG_PRESS_MS = 500;
    let pressTimer = null;
    let longPressed = false;

    const clearPress = () => {
      if (pressTimer) { clearTimeout(pressTimer); pressTimer = null; }
    };

    tile.addEventListener("pointerdown", () => {
      longPressed = false;
      clearPress();
      pressTimer = setTimeout(() => {
        longPressed = true;
        changeQty(boardName, cardId, -1);
      }, LONG_PRESS_MS);
    });

    tile.addEventListener("pointerup", () => clearPress());
    tile.addEventListener("pointercancel", () => clearPress());
    tile.addEventListener("pointerleave", () => clearPress());

    tile.addEventListener("click", (e) => {
      e.preventDefault();
      if (longPressed) { longPressed = false; return; }
      changeQty(boardName, cardId, +1);
    });

    tile.addEventListener("contextmenu", (e) => {
      e.preventDefault();
      clearPress();
      changeQty(boardName, cardId, -1);
    });

    tile.addEventListener("dblclick", (e) => {
      e.preventDefault();
      clearPress();
      const to = boardName === "main" ? "side" : "main";
      moveCard(boardName, to, cardId);
    });
  }

  function makeTile(boardName, it) {
    const tile = document.createElement("div");
    tile.className = "tile";
    tile.title = `${it.qty}x ${it.name}\nタップ/クリック:+1 / 長押し or 右クリック:-1 / ダブルタップ:移動`;

    const img = document.createElement("img");
    img.alt = it.name;
    img.src = it.image || "";
    img.loading = "lazy";
    img.onerror = () => { img.style.display = "none"; };

    const badge = document.createElement("div");
    badge.className = "badge";
    badge.textContent = it.qty;

    tile.append(img, badge);
    attachTileInteractions(tile, boardName, it.id);
    return tile;
  }

  function renderTiles(container, obj, boardName) {
    container.innerHTML = "";
    for (const it of listEntries(obj)) container.appendChild(makeTile(boardName, it));
  }

  function renderDeck() {
    $("mainCount").textContent = countBoard(state.deck.main);
    $("sideCount").textContent = countBoard(state.deck.side);
    renderTiles($("mainTiles"), state.deck.main, "main");
    renderTiles($("sideTiles"), state.deck.side, "side");
  }

  /* ===== events ===== */
  $("btnSearch").onclick = () => searchCards($("q").value);
  $("btnClear").onclick = () => {
    $("q").value = "";
    state.results = [];
    renderResults();
    setStatus("クリアしました");
    setSearchPage("form");
  };
  $("q").addEventListener("keydown", (e) => { if (e.key === "Enter") searchCards($("q").value); });

  $("order").addEventListener("change", () => { if ($("q").value.trim()) searchCards($("q").value); });
  $("preferJa").addEventListener("change", () => { /* 検索結果ページ中なら再検索してもOKだが、ここは何もしない */ });
  $("collapseSame").addEventListener("change", () => { /* 同上 */ });

  $("btnBackToForm").onclick = () => setSearchPage("form");
  $("viewModeGrid").onclick = () => setResultsMode("grid");
  $("viewModeList").onclick = () => setResultsMode("list");

  $("btnExport").onclick = exportDeck;
  $("btnClearBoards").onclick = clearBoards;

  $("btnSaveDeck").onclick = saveCurrentDeck;
  $("btnLoadDeck").onclick = () => {
    const name = $("deckSelect").value;
    if (!name) { setStatus("読み込むデッキを選択してください"); return; }
    loadDeckByName(name);
  };
  $("btnDeleteDeck").onclick = () => {
    const name = $("deckSelect").value || state.currentDeckName;
    if (!name) { setStatus("削除するデッキを選択してください"); return; }
    if (!confirm(`デッキ「${name}」を削除します。よろしいですか？`)) return;
    deleteDeckByName(name);
  };
  $("btnNewDeck").onclick = () => {
    if (!confirm("新規デッキを作成します（現在の未保存の変更は失われます）。よろしいですか？")) return;
    newDeck();
  };

  /* ===== init ===== */
  refreshDeckSelect();
  setCurrentDeckName("");
  renderResults();
  renderDeck();
  setStatus("待機中");

  setResultsMode(searchUI.mode);
  setSearchPage(searchUI.page);

  syncViewFromHash();
})();
</script>

<!-- Service Worker -->
<script>
if ("serviceWorker" in navigator) {
  navigator.serviceWorker.register("./sw.js").catch(() => {});
}
</script>
</body>
</html>
