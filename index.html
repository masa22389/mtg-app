<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>MTG Deck Builder</title>

  <!-- PWA -->
  <meta name="theme-color" content="#0b0c10">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <meta name="apple-mobile-web-app-title" content="MTGアプリ">
  <link rel="manifest" href="manifest.webmanifest">

  <style>
    :root{
      --bg:#0b0c10;
      --panel:#13151b;
      --text:#e7e7e7;
      --muted:#a8a8a8;
      --line:#242836;
      --chip:#151a26;
    }
    *{ box-sizing:border-box; }
    body{
      margin:0;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, "Noto Sans JP", sans-serif;
      background:var(--bg);
      color:var(--text);
    }

    header{
      padding:14px 16px 10px;
      border-bottom:1px solid var(--line);
      position:sticky;
      top:0;
      background:rgba(11,12,16,.92);
      backdrop-filter: blur(8px);
      z-index:10;
    }

    /* ===== Top tabs ===== */
    .topbar{ display:flex; align-items:flex-end; justify-content:space-between; gap:12px; flex-wrap:wrap; }
    .tabsWrap{
      display:flex;
      align-items:center;
      gap:10px;
      padding-bottom:8px;
      position:relative;
      width:100%;
      max-width: 520px;
    }
    .tabsWrap::after{
      content:"";
      position:absolute;
      left:0; right:0; bottom:0;
      border-bottom:3px double rgba(255,255,255,.18);
      pointer-events:none;
    }
    .tabs{ display:flex; gap:8px; }
    .tabbtn{
      padding:10px 14px;
      border-radius:14px;
      border:1px solid var(--line);
      background:#121623;
      color:var(--text);
      cursor:pointer;
      font-weight:900;
      min-width: 88px;
    }
    .tabbtn[aria-selected="true"]{
      background:#1b2130;
      outline:2px solid rgba(255,255,255,.10);
    }
    .pill{
      font-size:11px;
      color:var(--muted);
      border:1px solid var(--line);
      background:rgba(255,255,255,.03);
      padding:6px 10px;
      border-radius:999px;
      white-space:nowrap;
      font-variant-numeric: tabular-nums;
    }

    /* ===== Search toolbar layout (requested) ===== */
    .searchToolbar{
      margin-top:12px;
      display:flex;
      flex-direction:column;
      gap:10px;
    }
    .searchRow1{
      display:grid;
      grid-template-columns: 1fr auto;
      gap:10px;
      align-items:center;
    }
    .searchRow2{
      display:flex;
      gap:10px;
      align-items:center;
      flex-wrap:wrap;
    }
    .searchRow3{
      display:flex;
      flex-direction:column;
      gap:8px;
      padding-top:2px;
    }

    input[type="text"], input[type="search"]{
      padding:12px 12px;
      border-radius:12px;
      border:1px solid var(--line);
      background:#0f1117;
      color:var(--text);
      width:100%;
      min-width: 0;
    }
    select, button{
      padding:12px 12px;
      border-radius:12px;
      border:1px solid var(--line);
      background:#171b25;
      color:var(--text);
      cursor:pointer;
      white-space:nowrap;
    }
    button:hover{ background:#1b2130; }

    /* search dropdowns shouldn't be super wide */
    select{
      max-width: 220px;
    }
    #order{ width: 190px; }
    #viewMode{ width: 160px; }

    label{
      display:flex;
      align-items:center;
      gap:10px;
      font-size:13px;
      color:var(--muted);
      user-select:none;
    }
    label input{ width:18px; height:18px; }

    .content{ padding:12px; }
    .panel{ background:var(--panel); border:1px solid var(--line); border-radius:14px; overflow:hidden; }
    .status{
      padding:10px 12px;
      border-top:1px solid var(--line);
      color:var(--muted);
      font-size:12px;
      white-space:pre-wrap;
    }

    /* ===== Search results grid ===== */
    .grid{
      display:grid;
      grid-template-columns: repeat(auto-fill, minmax(140px, 1fr));
      gap:10px;
      padding:12px;
    }
    .card{
      border:1px solid var(--line);
      border-radius:14px;
      overflow:hidden;
      background:#0f1117;
      display:flex;
      flex-direction:column;
    }
    .card img{ width:100%; aspect-ratio: 0.714; object-fit:cover; background:#0b0c10; }
    .card .meta{ padding:10px; display:flex; flex-direction:column; gap:8px; }
    .card .name{ font-size:13px; line-height:1.25; font-weight:900; }
    .card .sub{ font-size:12px; color:var(--muted); }
    .card .actions{ display:flex; gap:6px; flex-wrap:wrap; }

    /* ===== Search results list (buttons under name, more dense) ===== */
    .list{
      display:flex;
      flex-direction:column;
      gap:8px;
      padding:12px;
    }
    .row{
      display:grid;
      grid-template-columns: 56px 1fr;
      gap:10px;
      align-items:start;
      border:1px solid var(--line);
      border-radius:14px;
      background:#0f1117;
      padding:10px;
    }
    .row img{
      width:56px;
      height:78px;
      object-fit:cover;
      border-radius:12px;
      background:#0b0c10;
      margin-top:2px;
    }
    .row .rmeta{ min-width:0; display:flex; flex-direction:column; gap:6px; }
    .row .rname{
      font-size:15px;
      font-weight:900;
      overflow:hidden;
      text-overflow:ellipsis;
      white-space:nowrap;
    }
    .row .rsub{
      font-size:12px;
      color:var(--muted);
      overflow:hidden;
      text-overflow:ellipsis;
      white-space:nowrap;
    }
    .row .ractions{
      display:flex;
      gap:8px;
      flex-wrap:wrap;
      margin-top:2px;
    }
    .row .ractions button{
      padding:10px 12px;
      border-radius:12px;
    }

    /* Views */
    .view{ display:none; }
    .view.active{ display:block; }

    /* ===== Deck ===== */
    .deckWrap{ padding:12px; display:flex; flex-direction:column; gap:12px; }
    .deckTop{ display:flex; gap:8px; flex-wrap:wrap; align-items:center; justify-content:space-between; }
    .deckTopLeft{ display:flex; gap:8px; align-items:center; flex-wrap:wrap; }

    .boards{ display:flex; gap:10px; }
    .board{
      flex:1;
      border:1px solid var(--line);
      border-radius:14px;
      background:#0f1117;
      overflow:hidden;
      min-width:0;
    }
    .boardHead{
      padding:10px 10px;
      border-bottom:1px solid var(--line);
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:8px;
    }
    .boardHeadLeft{ display:flex; align-items:center; gap:10px; }
    .chev{
      width:38px; height:38px;
      border-radius:12px;
      border:1px solid var(--line);
      background:#121623;
      display:grid; place-items:center;
      cursor:pointer;
      font-weight:900;
      user-select:none;
    }
    .boardTitle{ font-size:14px; font-weight:900; }
    .boardCount{ font-size:12px; color:var(--muted); font-variant-numeric: tabular-nums; }

    .tileWrap{ padding:10px; }
    .tileGrid{
      display:grid;
      grid-template-columns: repeat(auto-fill, minmax(78px, 1fr));
      gap:6px;
      max-height: min(58dvh, 58vh);
      overflow:auto;
      padding-right:4px;
    }
    .tile{
      position:relative;
      border:1px solid var(--line);
      border-radius:14px;
      background:#0b0c10;
      overflow:hidden;
      cursor:pointer;
      user-select:none;
      -webkit-tap-highlight-color: transparent;
      touch-action: manipulation;
    }
    .tile img{
      width:100%;
      aspect-ratio: 0.714;
      object-fit: cover;
      display:block;
      background:#07080c;
      pointer-events:none;
    }
    .badge{
      position:absolute;
      top:4px;
      right:4px;
      min-width:18px;
      padding:2px 6px;
      border-radius:999px;
      background:rgba(0,0,0,.75);
      border:1px solid rgba(255,255,255,.25);
      color:#fff;
      font-size:11px;
      font-weight:900;
      text-align:center;
      font-variant-numeric: tabular-nums;
      pointer-events:none;
    }

    /* Mobile layout */
    @media (max-width: 980px){
      .boards{ flex-direction: column; }
      .tileGrid{ max-height: min(46dvh, 46vh); }
      .tabsWrap{ max-width: 100%; }
      select{ max-width: 100%; }
    }
    /* Force 6 columns on phones (requested) */
    @media (max-width: 520px){
      .tileGrid{
        grid-template-columns: repeat(6, minmax(0, 1fr));
        gap:6px;
      }
      .badge{ font-size:10px; padding:2px 5px; }
      #order{ width: 160px; }
      #viewMode{ width: 150px; }
    }

    /* ===== Modal (smartphone safe) ===== */
    .modalOverlay{
      position: fixed;
      inset: 0;
      background: rgba(0,0,0,.55);
      display: none;
      align-items: center;
      justify-content: center;
      padding: 16px;
      z-index: 1000;
    }
    .modalOverlay.show{ display:flex; }

    .modal{
      width: min(920px, 100%);
      max-height: min(86dvh, 86vh);
      background: #10131a;
      border: 1px solid rgba(255,255,255,.10);
      border-radius: 18px;
      overflow: hidden;
      box-shadow: 0 20px 60px rgba(0,0,0,.55);
      display: flex;
      flex-direction: column;
    }
    .modalHeader{
      padding: 12px 14px;
      border-bottom: 1px solid rgba(255,255,255,.10);
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
      flex: 0 0 auto;
    }
    .modalTitle{ font-size:16px; font-weight:900; }
    .modalClose{
      border: 1px solid rgba(255,255,255,.12);
      background: rgba(255,255,255,.06);
      color: #fff;
      border-radius: 12px;
      padding: 8px 10px;
      cursor:pointer;
      min-width: 44px;
    }
    .modalBody{
      padding: 14px;
      overflow: auto;
      -webkit-overflow-scrolling: touch;
      flex: 1 1 auto;
    }
    @media (max-width: 980px){
      .modalOverlay{ align-items: flex-end; padding: 12px; }
      .modal{ max-height: min(88dvh, 88vh); border-radius: 18px; }
    }

    /* Card modal layout */
    .cardModalRow{
      display:grid;
      grid-template-columns: 120px 1fr;
      gap: 14px;
      align-items:start;
    }
    .cardModalRow img{
      width:120px;
      height:auto;
      aspect-ratio: 0.714;
      object-fit:cover;
      border-radius:14px;
      border:1px solid rgba(255,255,255,.08);
      background:#07080c;
    }
    .cardModalMeta .big{
      font-size:20px;
      font-weight:900;
      line-height:1.2;
      margin-bottom:10px;
    }
    .btnGrid{
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap:10px;
    }
    .btnWide{ grid-column: 1 / -1; }

    @media (max-width: 980px){
      .cardModalRow{ grid-template-columns: 96px 1fr; }
      .cardModalRow img{ width:96px; }
      .cardModalMeta .big{ font-size:18px; }
    }

    .field{
      display:flex;
      flex-direction:column;
      gap:6px;
      margin:10px 0;
    }
    .field input, .field select{ width:100%; }
    .hline{ height:1px; background:rgba(255,255,255,.08); margin:14px 0; }
  </style>
</head>
<body>

<header>
  <div class="topbar">
    <div class="tabsWrap" role="tablist" aria-label="画面切替">
      <div class="tabs">
        <button id="tabSearch" class="tabbtn" role="tab" aria-selected="true">検索</button>
        <button id="tabDeck" class="tabbtn" role="tab" aria-selected="false">デッキ</button>
      </div>
      <div class="pill" id="verBadge">ver 0.0.3</div>
    </div>
  </div>

  <!-- Search controls (layout per request) -->
  <div id="searchToolbar" class="searchToolbar">
    <div class="searchRow1">
      <input id="q" type="text" placeholder="検索" />
      <button id="btnSearch">検索</button>
    </div>

    <div class="searchRow2">
      <select id="order">
        <option value="name">並び（名前）</option>
        <option value="released">並び（発売日）</option>
        <option value="set">並び（セット）</option>
      </select>

      <button id="btnClear">クリア</button>

      <select id="viewMode" aria-label="表示モード">
        <option value="grid">表示（グリッド）</option>
        <option value="list">表示（リスト）</option>
      </select>
    </div>

    <div class="searchRow3">
      <label><input id="preferJa" type="checkbox" checked> 日本語版を優先（あれば）</label>
      <label><input id="collapseSame" type="checkbox"> 同名カードは1種類だけ（代表=最新印刷）</label>
    </div>
  </div>
</header>

<div class="content">
  <!-- ===== Search ===== -->
  <section id="viewSearch" class="view active">
    <div class="panel">
      <div id="resultsGrid" class="grid"></div>
      <div id="resultsList" class="list" style="display:none;"></div>
      <div id="status" class="status">待機中</div>
    </div>
  </section>

  <!-- ===== Deck ===== -->
  <section id="viewDeck" class="view">
    <div class="panel">
      <div class="deckWrap">
        <div class="deckTop">
          <div class="deckTopLeft">
            <span class="pill">現在: <b id="currentDeckName">（未保存）</b></span>
            <span class="pill">Main: <b id="mainCountTop">0</b></span>
            <span class="pill">Side: <b id="sideCountTop">0</b></span>
          </div>
          <div style="display:flex; gap:8px; flex-wrap:wrap;">
            <select id="sortDeck" aria-label="デッキ並び替え">
              <option value="name">並び（名前）</option>
              <option value="cmc">並び（マナコスト）</option>
              <option value="type">並び（種類）</option>
            </select>
            <button id="btnOpenSettings">⚙ 設定</button>
          </div>
        </div>

        <div class="boards">
          <div class="board">
            <div class="boardHead">
              <div class="boardHeadLeft">
                <div id="toggleMain" class="chev">▼</div>
                <div class="boardTitle">Main</div>
              </div>
              <div class="boardCount"><span id="mainCount">0</span>枚</div>
            </div>
            <div id="mainBody" class="tileWrap">
              <div id="mainTiles" class="tileGrid"></div>
            </div>
          </div>

          <div class="board">
            <div class="boardHead">
              <div class="boardHeadLeft">
                <div id="toggleSide" class="chev">▼</div>
                <div class="boardTitle">Side</div>
              </div>
              <div class="boardCount"><span id="sideCount">0</span>枚</div>
            </div>
            <div id="sideBody" class="tileWrap">
              <div id="sideTiles" class="tileGrid"></div>
            </div>
          </div>
        </div>

        <div style="display:flex; gap:8px; flex-wrap:wrap;">
          <button id="btnClearBoards" style="flex:1;">Main/Side 全消し</button>
        </div>
        <div class="status" id="deckStatus">待機中</div>
      </div>
    </div>
  </section>
</div>

<!-- ===== Card Operation Modal ===== -->
<div id="cardModalOverlay" class="modalOverlay" aria-hidden="true">
  <div class="modal" role="dialog" aria-modal="true" aria-labelledby="cardModalTitle">
    <div class="modalHeader">
      <div id="cardModalTitle" class="modalTitle">カード操作</div>
      <button class="modalClose" id="closeCardModal">×</button>
    </div>
    <div class="modalBody" id="cardModalBody"></div>
  </div>
</div>

<!-- ===== Deck Settings Modal ===== -->
<div id="settingsModalOverlay" class="modalOverlay" aria-hidden="true">
  <div class="modal" role="dialog" aria-modal="true" aria-labelledby="settingsModalTitle">
    <div class="modalHeader">
      <div id="settingsModalTitle" class="modalTitle">デッキ設定</div>
      <button class="modalClose" id="closeSettingsModal">×</button>
    </div>
    <div class="modalBody">
      <div class="field">
        <label style="color:var(--muted); font-size:12px;">デッキ名</label>
        <input id="deckName" type="text" placeholder="例：テスト2" />
      </div>

      <div style="display:flex; gap:10px; flex-wrap:wrap;">
        <button id="btnSaveDeck" style="flex:1;">保存</button>
        <button id="btnNewDeck" style="flex:1;">新規</button>
      </div>

      <div class="hline"></div>

      <div class="field">
        <label style="color:var(--muted); font-size:12px;">保存済みデッキ</label>
        <select id="deckSelect"></select>
      </div>

      <div style="display:flex; gap:10px; flex-wrap:wrap;">
        <button id="btnLoadDeck" style="flex:1;">読み込み</button>
        <button id="btnDeleteDeck" style="flex:1;">削除</button>
      </div>

      <div class="hline"></div>

      <div style="display:flex; gap:10px; flex-wrap:wrap;">
        <button id="btnCleanupZeros" style="flex:1;">0枚カードを掃除</button>
      </div>

      <div style="margin-top:10px; font-size:12px; color:var(--muted); text-align:center;">
        ※エクスポート機能は必要なら復活できます
      </div>
    </div>
  </div>
</div>

<script>
(() => {
  const $ = (id) => document.getElementById(id);

  // ===== Version =====
  const APP_VERSION = "0.0.3";

  // ===== Search view mode (grid/list) =====
  const SEARCH_VIEW_KEY = "mtg_search_view";
  let searchView = localStorage.getItem(SEARCH_VIEW_KEY) || "grid";

  // ===== Storage keys (backward compatible) =====
  const STORE_KEYS = [
    "mtg_deck_store_tabs_v2",
    "mtg_deck_store_v2",
    "mtg_deck_store_v1",
    "mtg_deck_store",
    "mtg_deck_store_v0"
  ];
  const STORE_KEY = STORE_KEYS[0]; // always save into tabs_v2

  const state = {
    results: [],
    deck: newEmptyDeck(""),
    currentDeckName: "",
    openCard: null, // { board:"main"|"side", id:"..." }
    boardCollapsed: { main:false, side:false }
  };

  /* ===== View switching ===== */
  function setView(view){
    const isSearch = view === "search";
    $("viewSearch").classList.toggle("active", isSearch);
    $("viewDeck").classList.toggle("active", !isSearch);

    $("tabSearch").setAttribute("aria-selected", String(isSearch));
    $("tabDeck").setAttribute("aria-selected", String(!isSearch));

    $("searchToolbar").style.display = isSearch ? "flex" : "none";

    const nextHash = isSearch ? "#search" : "#deck";
    if (location.hash !== nextHash) history.pushState(null, "", nextHash);
  }
  function syncViewFromHash(){
    const h = (location.hash || "").toLowerCase();
    if (h === "#deck") setView("deck");
    else setView("search");
  }
  $("tabSearch").onclick = () => setView("search");
  $("tabDeck").onclick = () => setView("deck");
  window.addEventListener("popstate", syncViewFromHash);
  window.addEventListener("hashchange", syncViewFromHash);

  function setStatus(msg){
    $("status").textContent = msg;
    const ds = $("deckStatus");
    if (ds) ds.textContent = msg;
  }

  /* ===== Search view toggle ===== */
  function setSearchView(mode){
    searchView = (mode === "list") ? "list" : "grid";
    localStorage.setItem(SEARCH_VIEW_KEY, searchView);

    const isGrid = searchView === "grid";
    $("resultsGrid").style.display = isGrid ? "grid" : "none";
    $("resultsList").style.display = isGrid ? "none" : "flex";

    $("viewMode").value = searchView;
    $("viewMode").options[0].textContent = "表示（グリッド）";
    $("viewMode").options[1].textContent = "表示（リスト）";
  }

  /* ===== Storage ===== */
  function loadStore(){
    for (const key of STORE_KEYS){
      try{
        const raw = localStorage.getItem(key);
        if (!raw) continue;
        const obj = JSON.parse(raw);
        if (obj && typeof obj === "object" && obj.decks && typeof obj.decks === "object"){
          if (key !== STORE_KEY){
            localStorage.setItem(STORE_KEY, JSON.stringify(obj));
          }
          if (!obj.version) obj.version = 2;
          return obj;
        }
      }catch{}
    }
    return { version:2, decks:{} };
  }
  function saveStore(store){ localStorage.setItem(STORE_KEY, JSON.stringify(store)); }

  function refreshDeckSelect(){
    const store = loadStore();
    const sel = $("deckSelect");
    sel.innerHTML = "";
    const names = Object.keys(store.decks).sort((a,b)=>a.localeCompare(b));

    const opt0 = document.createElement("option");
    opt0.value = "";
    opt0.textContent = "保存デッキを選択…";
    sel.appendChild(opt0);

    for (const n of names){
      const opt = document.createElement("option");
      opt.value = n;
      opt.textContent = n;
      sel.appendChild(opt);
    }
  }

  function newEmptyDeck(name){
    return { name, updatedAt: new Date().toISOString(), main:{}, side:{} };
  }

  function setCurrentDeckName(name){
    state.currentDeckName = name || "";
    $("currentDeckName").textContent = state.currentDeckName ? state.currentDeckName : "（未保存）";
  }

  /* ===== Scryfall ===== */
  function looksJapanese(s){ return /[\u3040-\u30FF\u4E00-\u9FFF]/.test(s); }
  function isAdvancedQuery(s){
    return /(^|\s)(t:|c:|o:|oracle:|f:|format:|lang:|is:|set:|cn:|rarity:|type:|pow|tou|cmc)\b/i.test(s) || /[:"]/g.test(s);
  }

  function getCardImage(card){
    if (card.image_uris?.normal) return card.image_uris.normal;
    if (Array.isArray(card.card_faces)) {
      for (const f of card.card_faces) if (f.image_uris?.normal) return f.image_uris.normal;
    }
    return "";
  }

  // 表示名：日本語版がある時は printed_name を優先
  function getDisplayName(card){
    return card.printed_name || card.name || "";
  }

  function getDisplayType(card){
    return card.printed_type_line || card.type_line || "";
  }

  function normalizeCard(card){
    return {
      id: card.id,
      oracle_id: card.oracle_id,
      name: getDisplayName(card),
      en_name: card.name || "",
      set: (card.set || "").toUpperCase(),
      collector: card.collector_number || "",
      lang: card.lang || "",
      released_at: card.released_at || "",
      scryfall_uri: card.scryfall_uri,
      image: getCardImage(card),
      cmc: typeof card.cmc === "number" ? card.cmc : Number(card.cmc || 0),
      type_line: getDisplayType(card)
    };
  }

  async function fetchSearch(q){
    const url = new URL("https://api.scryfall.com/cards/search");
    url.searchParams.set("q", q);
    url.searchParams.set("unique", "prints");
    url.searchParams.set("order", $("order").value);
    const res = await fetch(url.toString(), { headers:{ "Accept":"application/json" } });
    const data = await res.json().catch(()=>({}));
    return { ok: res.ok, data, status: res.status };
  }

  // collection: 既存デッキの英語名 → 日本語名へ補正用
  async function fetchCollectionByIds(ids){
    const url = "https://api.scryfall.com/cards/collection";
    const res = await fetch(url, {
      method: "POST",
      headers: { "Content-Type":"application/json", "Accept":"application/json" },
      body: JSON.stringify({ identifiers: ids.map(id => ({ id })) })
    });
    const data = await res.json().catch(()=>({}));
    return { ok: res.ok, data };
  }

  function looksEnglishName(name){
    if (!name) return true;
    return !/[\u3040-\u30FF\u4E00-\u9FFF]/.test(name);
  }

  async function upgradeDeckNamesToJapanese(){
    if (!$("preferJa")?.checked) return;

    const needIds = [];
    for (const b of ["main","side"]){
      const obj = (b === "side") ? state.deck.side : state.deck.main;
      for (const it of Object.values(obj)){
        if ((it.lang === "ja" || !it.lang) && looksEnglishName(it.name)){
          needIds.push(it.id);
        }
      }
    }

    const uniq = Array.from(new Set(needIds));
    if (uniq.length === 0) return;

    for (let i=0; i<uniq.length; i+=75){
      const batch = uniq.slice(i, i+75);
      const r = await fetchCollectionByIds(batch);
      const arr = Array.isArray(r.data?.data) ? r.data.data : [];

      for (const card of arr){
        const n = normalizeCard(card);
        for (const b of ["main","side"]){
          const obj = (b === "side") ? state.deck.side : state.deck.main;
          if (obj[n.id]){
            const qty = obj[n.id].qty ?? 1;
            obj[n.id] = { ...obj[n.id], ...n, qty };
          }
        }
      }
    }
  }

  function dateKey(d){ return (d && typeof d === "string") ? d : ""; }

  function exactRank(name, query){
    const a = (name||"").trim().toLowerCase();
    const q = (query||"").trim().toLowerCase();
    return a === q ? 0 : 1;
  }

  function pickBestPrint(cards, query, preferJa){
    let best = null;
    for (const c of cards){
      if (!best){ best = c; continue; }
      if (preferJa){
        const aj = (c.lang === "ja") ? 0 : 1;
        const bj = (best.lang === "ja") ? 0 : 1;
        if (aj !== bj){ if (aj < bj) best = c; continue; }
      }
      const ad = dateKey(c.released_at);
      const bd = dateKey(best.released_at);
      if (ad !== bd){ if (ad > bd) best = c; continue; }

      const aName = (c.printed_name || c.name || "");
      const bName = (best.printed_name || best.name || "");
      const ae = exactRank(aName, query);
      const be = exactRank(bName, query);
      if (ae !== be){ if (ae < be) best = c; continue; }

      const aKey = ((c.set||"") + "|" + (c.collector_number||"") + "|" + (c.id||"")).toLowerCase();
      const bKey = ((best.set||"") + "|" + (best.collector_number||"") + "|" + (best.id||"")).toLowerCase();
      if (aKey > bKey) best = c;
    }
    return best;
  }

  function applyCollapseSame(rawCards, query, preferJa, collapseSame){
    if (!collapseSame) return rawCards;
    const groups = new Map();
    for (const c of rawCards){
      const k = c.oracle_id || c.id;
      if (!groups.has(k)) groups.set(k, []);
      groups.get(k).push(c);
    }
    const picked = [];
    for (const arr of groups.values()) picked.push(pickBestPrint(arr, query, preferJa));
    return picked;
  }

  function sortResults(cards, query, preferJa){
    const qLower = (query||"").trim().toLowerCase();
    cards.sort((a,b)=>{
      const aname = (a.name||"").toLowerCase();
      const bname = (b.name||"").toLowerCase();
      const ae = aname === qLower ? 0 : 1;
      const be = bname === qLower ? 0 : 1;
      if (ae !== be) return ae - be;

      if (preferJa){
        const aj = (a.lang === "ja") ? 0 : 1;
        const bj = (b.lang === "ja") ? 0 : 1;
        if (aj !== bj) return aj - bj;
      }

      if (aname !== bname) return aname.localeCompare(bname);

      const ad = dateKey(a.released_at);
      const bd = dateKey(b.released_at);
      if (ad !== bd) return bd.localeCompare(ad);

      return (a.set||"").localeCompare(b.set||"");
    });
    return cards;
  }

  // ===== Furigana tolerant regex builder =====
  function escapeRegex(s){
    return String(s).replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
  }
  function buildFuriganaRegex(input){
    // 半角() / 全角（ ）どちらのふりがな括弧も許容
    const furigana = "(?:\\([^)]*\\)|（[^）]*）)?";
    // 文字間スペース：半角スペース/全角スペースを許容
    const gap = "[\\s　]*";
    const chars = Array.from(input.trim()).filter(ch => ch !== " " && ch !== "　");
    const parts = chars.map(ch => `${escapeRegex(ch)}${gap}${furigana}`);
    return parts.join(gap);
  }

  async function searchCards(rawInput){
    const s = rawInput.trim();
    if (!s){
      state.results = [];
      renderResults();
      setStatus("検索ワードを入力してください");
      return;
    }

    const preferJa = $("preferJa").checked;
    const collapseSame = $("collapseSame").checked;

    setStatus("検索中…");

    // Advanced query: keep as-is
    if (isAdvancedQuery(s)){
      const queries = (preferJa && looksJapanese(s) && !/(^|\s)lang:/i.test(s))
        ? [`lang:ja ${s}`, s]
        : [s];

      for (const q of queries){
        const r = await fetchSearch(q);
        const arr = Array.isArray(r.data?.data) ? r.data.data : [];
        if (arr.length > 0){
          let rawCards = arr;
          rawCards = applyCollapseSame(rawCards, s, preferJa, collapseSame);
          let cards = rawCards.map(normalizeCard);
          cards = sortResults(cards, s, preferJa);
          state.results = cards;
          renderResults();
          setStatus(`ヒット: ${cards.length}件`);
          return;
        }
      }

      state.results = [];
      renderResults();
      setStatus("見つかりませんでした");
      return;
    }

    const merged = new Map();
    const pushAll = (arr)=>{ for (const c of arr) merged.set(c.id, c); };

    // 1) Japanese first
    let jaHitCount = 0;
    if (preferJa){
      const rJa = await fetchSearch(`lang:ja ${s}`);
      const jaArr = Array.isArray(rJa.data?.data) ? rJa.data.data : [];
      jaHitCount = jaArr.length;
      pushAll(jaArr);

      // 1-2) Furigana fallback
      if (jaHitCount === 0 && looksJapanese(s)){
        const rx = buildFuriganaRegex(s);
        const rRx = await fetchSearch(`lang:ja name:/${rx}/`);
        const rxArr = Array.isArray(rRx.data?.data) ? rRx.data.data : [];
        pushAll(rxArr);

        // 保険：regexがダメならもう一回通常lang:ja
        if (rxArr.length === 0){
          const r2 = await fetchSearch(`lang:ja ${s}`);
          const arr2 = Array.isArray(r2.data?.data) ? r2.data.data : [];
          pushAll(arr2);
        }
      }
    }

    // 2) Any language fallback
    const rAny = await fetchSearch(s);
    pushAll(Array.isArray(rAny.data?.data) ? rAny.data.data : []);

    if (merged.size > 0){
      let rawCards = Array.from(merged.values());
      rawCards = applyCollapseSame(rawCards, s, preferJa, collapseSame);

      let cards = rawCards.map(normalizeCard);
      cards = sortResults(cards, s, preferJa);

      state.results = cards;
      renderResults();
      setStatus(`ヒット: ${cards.length}件`);
      return;
    }

    state.results = [];
    renderResults();
    setStatus("見つかりませんでした");
  }

  /* ===== Deck (Main/Side) ===== */
  function boardObj(board){ return board === "side" ? state.deck.side : state.deck.main; }

  function countBoard(obj){
    return Object.values(obj).reduce((sum,x)=>sum+(x.qty||0),0);
  }

  function listEntries(obj){
    const arr = Object.values(obj);
    const mode = $("sortDeck")?.value || "name";
    arr.sort((a,b)=>{
      if (mode === "cmc"){
        const ac = Number(a.cmc ?? 0);
        const bc = Number(b.cmc ?? 0);
        if (ac !== bc) return ac - bc;
      } else if (mode === "type"){
        const at = (a.type_line||"");
        const bt = (b.type_line||"");
        if (at !== bt) return at.localeCompare(bt);
      }
      return (a.name||"").localeCompare(b.name||"");
    });
    return arr;
  }

  function addToBoard(board, card, delta=1){
    const obj = boardObj(board);
    const cur = obj[card.id];
    if (cur) cur.qty += delta;
    else obj[card.id] = { ...card, qty: delta };
    state.deck.updatedAt = new Date().toISOString();
    renderDeck();
  }

  function changeQty(board, cardId, delta, keepZero=false){
    const obj = boardObj(board);
    const it = obj[cardId];
    if (!it) return;

    it.qty += delta;

    if (it.qty <= 0){
      if (keepZero) it.qty = 0;
      else delete obj[cardId];
    }

    state.deck.updatedAt = new Date().toISOString();
    renderDeck();

    if (state.openCard && state.openCard.board === board && state.openCard.id === cardId){
      renderCardModal();
    }
  }

  function moveCard(from, to, cardId){
    if (from === to) return;
    const a = boardObj(from);
    const b = boardObj(to);
    const it = a[cardId];
    if (!it) return;
    if ((it.qty||0) <= 0) return;

    if (b[cardId]) b[cardId].qty += it.qty;
    else b[cardId] = it;
    delete a[cardId];

    state.deck.updatedAt = new Date().toISOString();
    renderDeck();

    if (state.openCard && state.openCard.id === cardId){
      state.openCard.board = to;
      renderCardModal();
    }
  }

  function cleanupZeros(){
    for (const b of ["main","side"]){
      const obj = boardObj(b);
      for (const id of Object.keys(obj)){
        if ((obj[id]?.qty ?? 0) <= 0) delete obj[id];
      }
    }
  }

  function clearBoards(){
    state.deck.main = {};
    state.deck.side = {};
    state.deck.updatedAt = new Date().toISOString();
    setCurrentDeckName("");
    renderDeck();
    setStatus("Main/Side を全消ししました");
  }

  /* ===== Render ===== */
  function renderResults(){
    const grid = $("resultsGrid");
    const list = $("resultsList");
    grid.innerHTML = "";
    list.innerHTML = "";

    for (const c of state.results){
      const wrap = document.createElement("div");
      wrap.className = "card";

      const img = document.createElement("img");
      img.loading = "lazy";
      img.alt = c.name;
      img.src = c.image || "";
      img.onerror = () => { img.style.display = "none"; };

      const meta = document.createElement("div");
      meta.className = "meta";

      const name = document.createElement("div");
      name.className = "name";
      name.textContent = c.name;

      const sub = document.createElement("div");
      sub.className = "sub";
      sub.textContent = `${c.set}${c.collector ? " #" + c.collector : ""}${c.lang ? " / " + c.lang : ""}${c.released_at ? " / " + c.released_at : ""}`;

      const actions = document.createElement("div");
      actions.className = "actions";

      const btnMain = document.createElement("button");
      btnMain.textContent = "Mainに追加";
      btnMain.onclick = () => addToBoard("main", c, 1);

      const btnSide = document.createElement("button");
      btnSide.textContent = "Sideに追加";
      btnSide.onclick = () => addToBoard("side", c, 1);

      const btnOpen = document.createElement("button");
      btnOpen.textContent = "詳細";
      btnOpen.onclick = () => window.open(c.scryfall_uri, "_blank", "noopener,noreferrer");

      actions.append(btnMain, btnSide, btnOpen);
      meta.append(name, sub, actions);
      wrap.append(img, meta);
      grid.appendChild(wrap);

      const row = document.createElement("div");
      row.className = "row";

      const limg = document.createElement("img");
      limg.loading = "lazy";
      limg.alt = c.name;
      limg.src = c.image || "";
      limg.onerror = () => { limg.style.display = "none"; };

      const rmeta = document.createElement("div");
      rmeta.className = "rmeta";

      const rname = document.createElement("div");
      rname.className = "rname";
      rname.textContent = c.name;

      const ractions = document.createElement("div");
      ractions.className = "ractions";

      const lMain = document.createElement("button");
      lMain.textContent = "Main";
      lMain.onclick = () => addToBoard("main", c, 1);

      const lSide = document.createElement("button");
      lSide.textContent = "Side";
      lSide.onclick = () => addToBoard("side", c, 1);

      const lOpen = document.createElement("button");
      lOpen.textContent = "詳細";
      lOpen.onclick = () => window.open(c.scryfall_uri, "_blank", "noopener,noreferrer");

      ractions.append(lMain, lSide, lOpen);

      const rsub = document.createElement("div");
      rsub.className = "rsub";
      rsub.textContent = `${c.set}${c.collector ? " #" + c.collector : ""}${c.lang ? " / " + c.lang : ""}${c.released_at ? " / " + c.released_at : ""}`;

      rmeta.append(rname, rsub, ractions);

      row.append(limg, rmeta);
      list.appendChild(row);
    }
  }

  function makeTile(boardName, it){
    const tile = document.createElement("div");
    tile.className = "tile";
    tile.title = `${it.qty}x ${it.name}`;

    const img = document.createElement("img");
    img.alt = it.name;
    img.src = it.image || "";
    img.loading = "lazy";
    img.onerror = () => { img.style.display = "none"; };

    const badge = document.createElement("div");
    badge.className = "badge";
    badge.textContent = it.qty;

    tile.append(img, badge);

    tile.addEventListener("click", (e)=>{
      e.preventDefault();
      openCardModal(boardName, it.id);
    });

    return tile;
  }

  function renderTiles(container, obj, boardName){
    container.innerHTML = "";
    for (const it of listEntries(obj)){
      container.appendChild(makeTile(boardName, it));
    }
  }

  function renderDeck(){
    const mc = countBoard(state.deck.main);
    const sc = countBoard(state.deck.side);

    $("mainCount").textContent = mc;
    $("sideCount").textContent = sc;
    $("mainCountTop").textContent = mc;
    $("sideCountTop").textContent = sc;

    $("mainBody").style.display = state.boardCollapsed.main ? "none" : "block";
    $("sideBody").style.display = state.boardCollapsed.side ? "none" : "block";
    $("toggleMain").textContent = state.boardCollapsed.main ? "▶" : "▼";
    $("toggleSide").textContent = state.boardCollapsed.side ? "▶" : "▼";

    renderTiles($("mainTiles"), state.deck.main, "main");
    renderTiles($("sideTiles"), state.deck.side, "side");
  }

  /* ===== Modals ===== */
  function showOverlay(id){
    const ov = $(id);
    ov.classList.add("show");
    ov.setAttribute("aria-hidden","false");
  }
  function hideOverlay(id){
    const ov = $(id);
    ov.classList.remove("show");
    ov.setAttribute("aria-hidden","true");
  }

  function openCardModal(board, cardId){
    state.openCard = { board, id: cardId };
    renderCardModal();
    showOverlay("cardModalOverlay");
  }

  function closeCardModal(){
    cleanupZeros();
    state.openCard = null;
    hideOverlay("cardModalOverlay");
    renderDeck();
  }

  function renderCardModal(){
    const body = $("cardModalBody");
    if (!state.openCard){
      body.innerHTML = "";
      return;
    }
    const { board, id } = state.openCard;
    const obj = boardObj(board);
    const it = obj[id];

    const safe = it || { id, name:"(カード)", qty:0, scryfall_uri:"#", image:"" };

    $("cardModalTitle").textContent = `${board === "main" ? "Main" : "Side"}のカード操作`;

    // カード名の下の "USG #174 / ja / ..." の行は出さない
    body.innerHTML = `
      <div class="cardModalRow">
        <img src="${safe.image || ""}" alt="">
        <div class="cardModalMeta">
          <div class="big">${safe.qty}x ${escapeHtml(safe.name || "")}</div>

          <div class="btnGrid">
            <button id="cmPlus">+1</button>
            <button id="cmMinus">-1</button>
            <button id="cmMove" class="btnWide">${board === "main" ? "Sideへ移動" : "Mainへ移動"}</button>
            <button id="cmOpen" class="btnWide">Scryfall</button>
          </div>
        </div>
      </div>
    `;

    $("cmPlus").onclick  = () => changeQty(board, id, +1, true);
    $("cmMinus").onclick = () => changeQty(board, id, -1, true);

    $("cmMove").onclick = () => {
      const to = board === "main" ? "side" : "main";
      moveCard(board, to, id);
    };

    $("cmOpen").onclick = () => {
      if (safe.scryfall_uri && safe.scryfall_uri !== "#") window.open(safe.scryfall_uri, "_blank", "noopener,noreferrer");
    };

    if ((safe.qty||0) <= 0) $("cmMove").disabled = true;
  }

  function openSettingsModal(){
    $("deckName").value = state.currentDeckName || "";
    refreshDeckSelect();
    showOverlay("settingsModalOverlay");
  }
  function closeSettingsModal(){
    hideOverlay("settingsModalOverlay");
  }

  /* ===== Save/Load/Delete ===== */
  function saveCurrentDeck(){
    const name = $("deckName").value.trim();
    if (!name){ setStatus("デッキ名を入力してください"); return; }

    const store = loadStore();
    const toSave = structuredClone(state.deck);
    toSave.name = name;
    toSave.updatedAt = new Date().toISOString();

    store.decks[name] = toSave;
    saveStore(store);

    setCurrentDeckName(name);
    setStatus(`保存しました: ${name}`);
    refreshDeckSelect();
  }

  async function loadDeckByName(name){
    const store = loadStore();
    const d = store.decks[name];
    if (!d){ setStatus(`見つかりません: ${name}`); return; }

    state.deck = {
      name: d.name || name,
      updatedAt: d.updatedAt || new Date().toISOString(),
      main: d.main || {},
      side: d.side || {}
    };
    setCurrentDeckName(name);
    renderDeck();

    // 既存デッキの英語名 → 日本語名へ補正
    await upgradeDeckNamesToJapanese();
    renderDeck();

    setStatus(`読み込みました: ${name}`);
  }

  function deleteDeckByName(name){
    const store = loadStore();
    if (!store.decks[name]){ setStatus(`見つかりません: ${name}`); return; }
    delete store.decks[name];
    saveStore(store);
    refreshDeckSelect();
    setStatus(`削除しました: ${name}`);
    if (state.currentDeckName === name){
      setCurrentDeckName("");
      state.deck = newEmptyDeck("");
      renderDeck();
    }
  }

  function newDeck(){
    state.deck = newEmptyDeck("");
    setCurrentDeckName("");
    renderDeck();
    setStatus("新規デッキを作成しました");
  }

  /* ===== helpers ===== */
  function escapeHtml(s){
    return String(s)
      .replaceAll("&","&amp;")
      .replaceAll("<","&lt;")
      .replaceAll(">","&gt;")
      .replaceAll('"',"&quot;")
      .replaceAll("'","&#039;");
  }

  /* ===== events ===== */
  $("btnSearch").onclick = () => searchCards($("q").value);
  $("btnClear").onclick = () => { $("q").value=""; state.results=[]; renderResults(); setStatus("クリアしました"); };
  $("q").addEventListener("keydown", (e)=>{ if (e.key==="Enter") searchCards($("q").value); });

  $("order").addEventListener("change", ()=>{ if ($("q").value.trim()) searchCards($("q").value); });
  $("preferJa").addEventListener("change", async ()=>{
    if ($("q").value.trim()) searchCards($("q").value);
    // デッキ側もその場で可能なら日本語化
    await upgradeDeckNamesToJapanese();
    renderDeck();
  });
  $("collapseSame").addEventListener("change", ()=>{ if ($("q").value.trim()) searchCards($("q").value); });

  $("viewMode").addEventListener("change", ()=> setSearchView($("viewMode").value));

  $("toggleMain").onclick = () => { state.boardCollapsed.main = !state.boardCollapsed.main; renderDeck(); };
  $("toggleSide").onclick = () => { state.boardCollapsed.side = !state.boardCollapsed.side; renderDeck(); };

  $("btnClearBoards").onclick = () => {
    if (!confirm("Main/Side を全消しします。よろしいですか？")) return;
    clearBoards();
  };

  $("btnOpenSettings").onclick = openSettingsModal;

  $("closeCardModal").onclick = closeCardModal;
  $("closeSettingsModal").onclick = closeSettingsModal;

  $("cardModalOverlay").addEventListener("click", (e)=>{
    if (e.target === $("cardModalOverlay")) closeCardModal();
  });
  $("settingsModalOverlay").addEventListener("click", (e)=>{
    if (e.target === $("settingsModalOverlay")) closeSettingsModal();
  });

  $("btnSaveDeck").onclick = saveCurrentDeck;
  $("btnNewDeck").onclick = () => {
    if (!confirm("新規デッキを作成します（未保存の変更は失われます）。よろしいですか？")) return;
    newDeck();
  };
  $("btnLoadDeck").onclick = async () => {
    const name = $("deckSelect").value;
    if (!name){ setStatus("読み込むデッキを選択してください"); return; }
    await loadDeckByName(name);
    closeSettingsModal();
  };
  $("btnDeleteDeck").onclick = () => {
    const name = $("deckSelect").value || state.currentDeckName;
    if (!name){ setStatus("削除するデッキを選択してください"); return; }
    if (!confirm(`デッキ「${name}」を削除します。よろしいですか？`)) return;
    deleteDeckByName(name);
  };
  $("btnCleanupZeros").onclick = () => {
    cleanupZeros();
    renderDeck();
    setStatus("0枚カードを掃除しました");
  };

  $("sortDeck").addEventListener("change", renderDeck);

  /* ===== init ===== */
  $("verBadge").textContent = `ver ${APP_VERSION}`;
  loadStore();
  refreshDeckSelect();

  setCurrentDeckName("");
  renderResults();
  renderDeck();
  setStatus("待機中");
  setSearchView(searchView);
  syncViewFromHash();

})();
</script>

<!-- Service Worker -->
<script>
if ("serviceWorker" in navigator) {
  navigator.serviceWorker.register("./sw.js").catch(() => {});
}
</script>

</body>
</html>
